OK, d√©veloppons l‚Äôoption 2 : z√©ro Exchange properties, et l‚Äôagr√©gateur additionne des BigDecimal d√©j√† port√©s par l‚Äôobjet.

Id√©e

Tu continues √† ‚Äútyper‚Äù dans le mod√®le d‚Äôentr√©e (MarginCallCsvLine.computeTyped()).

Ton map() copie ces valeurs typ√©es dans le mod√®le de sortie (dans des champs transient non-CSV).

L‚ÄôAggregationStrategy additionne directement row.nominalValue et row.nominalEuroValue.

finalizeGroup() √©crit les strings finales NOMINAL / NOMINAL_EURO (avec virgule) puis √©ventuellement remet les typed √† z√©ro (optionnel).


‚úÖ R√©sultat : route plus simple, pas de propri√©t√©s, pas de parsing dans l‚Äôaggregate.


---

1) Entr√©e : MarginCallCsvLine (inchang√©, typage interne)

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

import java.math.BigDecimal;

@CsvRecord(separator = "\\|", skipFirstLine = true)
public class MarginCallCsvLine {

    @DataField(pos = 1, required = false)  public String CONTRACT_ID;
    @DataField(pos = 2, required = false)  public String CODE_BOM;
    @DataField(pos = 3, required = false)  public String DIRECTION;
    @DataField(pos = 4, required = false)  public String CURRENCY;

    @DataField(pos = 5, required = false)  public String NOMINAL;
    @DataField(pos = 6, required = false)  public String CLEAN_PRICE;
    @DataField(pos = 7, required = false)  public String ACCRUAL;

    @DataField(pos = 8, required = false)  public String PV_CURRENCY;
    @DataField(pos = 9, required = false)  public String PV_EUR;

    @DataField(pos = 10, required = false) public String PV_HC_CURRENCY;
    @DataField(pos = 11, required = false) public String PV_HC_EUR;

    @DataField(pos = 12, required = false) public String HAIRCUT;
    @DataField(pos = 13, required = false) public String DATE_TRT;
    @DataField(pos = 14, required = false) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15, required = false) public String NOMINAL_EURO;

    // champs typ√©s internes
    public transient BigDecimal nominalValue = BigDecimal.ZERO;
    public transient BigDecimal nominalEuroValue = BigDecimal.ZERO;

    public MarginCallCsvLine computeTyped() {
        this.nominalValue = parseFrDecimal(this.NOMINAL);
        this.nominalEuroValue = parseFrDecimal(this.NOMINAL_EURO);
        return this;
    }

    private static BigDecimal parseFrDecimal(String s) {
        if (s == null || s.isBlank()) return BigDecimal.ZERO;
        String cleaned = s.replaceAll("[^0-9,\\.\\-]", "").trim();
        if (cleaned.isEmpty() || ".".equals(cleaned) || "-".equals(cleaned)) return BigDecimal.ZERO;
        cleaned = cleaned.replace(',', '.');
        return new BigDecimal(cleaned);
    }
}


---

2) Sortie : MarginCallSfdhLine (CSV String + 2 champs transient BigDecimal)

üëâ C‚Äôest √ßa le c≈ìur de l‚Äôoption 2 : tu ajoutes deux champs typ√©s internes dans le mod√®le de sortie aussi.

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

import java.math.BigDecimal;

@CsvRecord(separator = "\\|", skipFirstLine = false, generateHeaderColumns = false)
public class MarginCallSfdhLine {

    @DataField(pos = 1)  public String CONTRACT_ID;
    @DataField(pos = 2)  public String CODE_BOM;
    @DataField(pos = 3)  public String DIRECTION;
    @DataField(pos = 4)  public String CURRENCY;

    @DataField(pos = 5)  public String NOMINAL;       // rendu CSV
    @DataField(pos = 6)  public String CLEAN_PRICE;
    @DataField(pos = 7)  public String ACCRUAL;

    @DataField(pos = 8)  public String PV_CURRENCY;
    @DataField(pos = 9)  public String PV_EUR;

    @DataField(pos = 10) public String PV_HC_CURRENCY;
    @DataField(pos = 11) public String PV_HC_EUR;

    @DataField(pos = 12) public String HAIRCUT;
    @DataField(pos = 13) public String DATE_TRT;
    @DataField(pos = 14) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15) public String NOMINAL_EURO;  // rendu CSV

    // ‚úÖ champs internes typ√©s (Bindy ignore car pas de @DataField)
    public transient BigDecimal nominalValue = BigDecimal.ZERO;
    public transient BigDecimal nominalEuroValue = BigDecimal.ZERO;
}


---

3) Bean unique : MarginCallProcessor (map + aggregate + finalize) sans Exchange properties

import org.apache.camel.AggregationStrategy;
import org.apache.camel.Exchange;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Component
public class MarginCallProcessor implements AggregationStrategy {

    // ---- map CSV -> SFDH + copie des typed values ----
    public MarginCallSfdhLine map(MarginCallCsvLine in) {
        MarginCallSfdhLine o = new MarginCallSfdhLine();

        o.CONTRACT_ID = in.CONTRACT_ID;
        o.CODE_BOM    = in.CODE_BOM;
        o.DIRECTION   = in.DIRECTION;
        o.CURRENCY    = in.CURRENCY;

        // strings nettoy√©es (comme BW)
        o.NOMINAL     = commaToDot(remove(in.NOMINAL));
        o.CLEAN_PRICE = remove(in.CLEAN_PRICE);

        String acc = remove(in.ACCRUAL);
        o.ACCRUAL = (acc != null && !acc.isBlank()) ? acc : "0,0";

        o.PV_CURRENCY    = remove(in.PV_CURRENCY);
        o.PV_EUR         = remove(in.PV_EUR);
        o.PV_HC_CURRENCY = remove(in.PV_HC_CURRENCY);
        o.PV_HC_EUR      = remove(in.PV_HC_EUR);
        o.HAIRCUT        = remove(in.HAIRCUT);

        o.DATE_TRT = in.DATE_TRT;
        o.BANKRUPTCY_REMOTE = remove(in.BANKRUPTCY_REMOTE);

        o.NOMINAL_EURO = commaToDot(remove(in.NOMINAL_EURO));

        // ‚úÖ copie des valeurs typ√©es calcul√©es √† l'entr√©e (1 seul parsing)
        o.nominalValue = (in.nominalValue != null) ? in.nominalValue : BigDecimal.ZERO;
        o.nominalEuroValue = (in.nominalEuroValue != null) ? in.nominalEuroValue : BigDecimal.ZERO;

        return o;
    }

    // ---- aggregate : somme directement sur BigDecimal internes ----
    @Override
    public Exchange aggregate(Exchange oldEx, Exchange newEx) {
        MarginCallSfdhLine row = newEx.getIn().getBody(MarginCallSfdhLine.class);

        BigDecimal n = row.nominalValue != null ? row.nominalValue : BigDecimal.ZERO;
        BigDecimal e = row.nominalEuroValue != null ? row.nominalEuroValue : BigDecimal.ZERO;

        if (oldEx == null) {
            // 1√®re ligne du groupe = conserv√©e (comme current-group()[1])
            // on la garde et elle porte d√©j√† ses valeurs typ√©es
            return newEx;
        }

        MarginCallSfdhLine kept = oldEx.getIn().getBody(MarginCallSfdhLine.class);
        kept.nominalValue = safe(kept.nominalValue).add(n);
        kept.nominalEuroValue = safe(kept.nominalEuroValue).add(e);

        // on ne touche pas aux autres champs => ceux de la 1√®re ligne restent
        return oldEx;
    }

    // ---- finalize : √©crit les sommes format√©es (virgule) dans les champs CSV ----
    public void finalizeGroup(Exchange exchange) {
        MarginCallSfdhLine kept = exchange.getIn().getBody(MarginCallSfdhLine.class);
        kept.NOMINAL = formatWithComma(kept.nominalValue);
        kept.NOMINAL_EURO = formatWithComma(kept.nominalEuroValue);
    }

    // ---- helpers ----
    private BigDecimal safe(BigDecimal v) { return v != null ? v : BigDecimal.ZERO; }

    private String remove(String s) {
        if (s == null) return null;
        return s.replaceAll("[^0-9A-Za-z,\\.\\-]", "");
    }

    private String commaToDot(String s) {
        return s == null ? null : s.replace(',', '.');
    }

    private String formatWithComma(BigDecimal v) {
        if (v == null) v = BigDecimal.ZERO;
        return v.stripTrailingZeros().toPlainString().replace('.', ',');
    }
}


---

4) Route Camel (tr√®s lisible, sans properties)

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat;
import org.springframework.stereotype.Component;

@Component
public class MarginCallRoute extends RouteBuilder {

    private final MarginCallProcessor proc;

    public MarginCallRoute(MarginCallProcessor proc) {
        this.proc = proc;
    }

    @Override
    public void configure() {

        BindyCsvDataFormat inCsv  = new BindyCsvDataFormat(MarginCallCsvLine.class);
        BindyCsvDataFormat outCsv = new BindyCsvDataFormat(MarginCallSfdhLine.class);

        from("file:{{in.dir}}?include=.*\\.csv&noop=true")
            .routeId("margincall-pret-emprunt")
            .unmarshal(inCsv)                 // List<MarginCallCsvLine>
            .split(body())
                .bean(MarginCallCsvLine.class, "computeTyped") // parse 1 fois
                .bean(proc, "map")                             // -> MarginCallSfdhLine (porte BigDecimal internes)
                .aggregate(simple("${body.CODE_BOM}"), proc)
                    .completionFromBatchConsumer()
                    .bean(proc, "finalizeGroup")
                .end()
            .end()
            .marshal(outCsv)
            .to("file:{{out.dir}}?fileName=${file:name.noext}_AGG.csv");
    }
}


---

Pourquoi cette option 2 est top

‚úÖ Route ultra lisible
‚úÖ Pas de Exchange.setProperty / getProperty
‚úÖ Z√©ro parsing dans aggregate()
‚úÖ 1 parsing par ligne (dans computeTyped)
‚úÖ Output reste conforme √† ton XSD (strings)


---

Si tu veux, je peux aussi te donner une variante qui valide que les champs ‚Äúnon somm√©s‚Äù sont identiques dans un m√™me CODE_BOM (sinon log warn / throw), mais BW ne le faisait pas donc c‚Äôest optionnel.
