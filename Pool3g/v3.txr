@Component
public class ValoPool3GGlobalAggregator implements AggregationStrategy {

  private final ValoPool3GProcessor proc;

  public ValoPool3GGlobalAggregator(ValoPool3GProcessor proc) {
    this.proc = proc;
  }

  @Override
  public Exchange aggregate(Exchange oldEx, Exchange newEx) {
    SfdhMarginCallLine row = newEx.getIn().getBody(SfdhMarginCallLine.class);

    if (oldEx == null) {
      // on initialise la map dans l'exchange
      Map<String, SfdhMarginCallLine> map = new LinkedHashMap<>();
      map.put(row.getCodeBom(), row);
      newEx.setProperty("aggMap", map);
      return newEx;
    }

    @SuppressWarnings("unchecked")
    Map<String, SfdhMarginCallLine> map = oldEx.getProperty("aggMap", Map.class);

    // si existe, on additionne; sinon on garde la 1ère ligne du groupe
    SfdhMarginCallLine kept = map.get(row.getCodeBom());
    if (kept == null) {
      map.put(row.getCodeBom(), row);
    } else {
      kept.nominalValue = kept.nominalValue.add(row.nominalValue);
      kept.nominalEuroValue = kept.nominalEuroValue.add(row.nominalEuroValue);
    }

    return oldEx;
  }

  public void finalizeAll(Exchange exchange) {
    @SuppressWarnings("unchecked")
    Map<String, SfdhMarginCallLine> map = exchange.getProperty("aggMap", Map.class);

    // applique les formats CSV sur chaque ligne
    for (SfdhMarginCallLine line : map.values()) {
      Exchange tmp = exchange.copy();
      tmp.getIn().setBody(line);
      proc.finalizeGroup(tmp); // réutilise ton code existant 2
    }

    exchange.getIn().setBody(new ArrayList<>(map.values()));
  }
}

.split(body())
  .process(e -> e.getIn().getBody(CalypsoMarginCall.class).computeTyped())
  .bean(proc, "map")
.end()
.aggregate(constant(true), globalAgg)   // <-- 1 seul groupe
  .completionFromBatchConsumer()
  .bean(globalAgg, "finalizeAll")       // <-- transforme Map -> List + formats
  .marshal(outCsv)
  .to("file:{{eai.report.valo.pool3g.daily.output.dir}}?fileName=${exchangeProperty.inputFileName}")
    .end();
