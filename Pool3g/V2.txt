Voici la version “clean” : 2 modèles + 1 seul bean (qui fait mapping + agrégation + finalize).
La route devient courte et tu ne fais plus d’allers-retours mentalement.


---

1) Modèle d’entrée (CSV) MarginCallCsvLine (header présent)

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

@CsvRecord(separator = "\\|", skipFirstLine = true)
public class MarginCallCsvLine {
    @DataField(pos = 1, required = false)  public String CONTRACT_ID;
    @DataField(pos = 2, required = false)  public String CODE_BOM;
    @DataField(pos = 3, required = false)  public String DIRECTION;
    @DataField(pos = 4, required = false)  public String CURRENCY;

    @DataField(pos = 5, required = false)  public String NOMINAL;
    @DataField(pos = 6, required = false)  public String CLEAN_PRICE;
    @DataField(pos = 7, required = false)  public String ACCRUAL;

    @DataField(pos = 8, required = false)  public String PV_CURRENCY;
    @DataField(pos = 9, required = false)  public String PV_EUR;

    @DataField(pos = 10, required = false) public String PV_HC_CURRENCY;
    @DataField(pos = 11, required = false) public String PV_HC_EUR;

    @DataField(pos = 12, required = false) public String HAIRCUT;
    @DataField(pos = 13, required = false) public String DATE_TRT;
    @DataField(pos = 14, required = false) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15, required = false) public String NOMINAL_EURO;
}


---

2) Modèle de sortie (CSV final) MarginCallSfdhLine

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

@CsvRecord(separator = "\\|", skipFirstLine = false, generateHeaderColumns = false)
public class MarginCallSfdhLine {
    @DataField(pos = 1)  public String CONTRACT_ID;
    @DataField(pos = 2)  public String CODE_BOM;
    @DataField(pos = 3)  public String DIRECTION;
    @DataField(pos = 4)  public String CURRENCY;

    @DataField(pos = 5)  public String NOMINAL;
    @DataField(pos = 6)  public String CLEAN_PRICE;
    @DataField(pos = 7)  public String ACCRUAL;

    @DataField(pos = 8)  public String PV_CURRENCY;
    @DataField(pos = 9)  public String PV_EUR;

    @DataField(pos = 10) public String PV_HC_CURRENCY;
    @DataField(pos = 11) public String PV_HC_EUR;

    @DataField(pos = 12) public String HAIRCUT;
    @DataField(pos = 13) public String DATE_TRT;
    @DataField(pos = 14) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15) public String NOMINAL_EURO;
}


---

3) Bean unique MarginCallProcessor (map + aggregate + finalize)

import org.apache.camel.AggregationStrategy;
import org.apache.camel.Exchange;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Component
public class MarginCallProcessor implements AggregationStrategy {

    private static final String SUM_NOMINAL = "sumNominal";
    private static final String SUM_NOMINAL_EUR = "sumNominalEuro";

    // --------- (A) Mapping CSV -> SFDH (équivalent XSLT Map-Data) ----------
    public MarginCallSfdhLine map(MarginCallCsvLine in) {
        MarginCallSfdhLine o = new MarginCallSfdhLine();

        o.CONTRACT_ID = in.CONTRACT_ID;
        o.CODE_BOM    = in.CODE_BOM;
        o.DIRECTION   = in.DIRECTION;
        o.CURRENCY    = in.CURRENCY;

        o.NOMINAL     = commaToDot(remove(in.NOMINAL));
        o.CLEAN_PRICE = remove(in.CLEAN_PRICE);

        String acc = remove(in.ACCRUAL);
        o.ACCRUAL = (acc != null && !acc.isBlank()) ? acc : "0,0";

        o.PV_CURRENCY    = remove(in.PV_CURRENCY);
        o.PV_EUR         = remove(in.PV_EUR);
        o.PV_HC_CURRENCY = remove(in.PV_HC_CURRENCY);
        o.PV_HC_EUR      = remove(in.PV_HC_EUR);
        o.HAIRCUT        = remove(in.HAIRCUT);

        o.DATE_TRT = in.DATE_TRT;
        o.BANKRUPTCY_REMOTE = remove(in.BANKRUPTCY_REMOTE);

        o.NOMINAL_EURO = commaToDot(remove(in.NOMINAL_EURO));

        return o;
    }

    // --------- (B) AggregationStrategy : group-by CODE_BOM (équivalent for-each-group) ----------
    @Override
    public Exchange aggregate(Exchange oldEx, Exchange newEx) {
        MarginCallSfdhLine row = newEx.getIn().getBody(MarginCallSfdhLine.class);

        if (oldEx == null) {
            // garde la 1ère ligne (comme current-group()[1]) + init sommes
            setSum(oldEx = newEx, parse(row.NOMINAL), parse(row.NOMINAL_EURO));
            return oldEx;
        }

        // cumule seulement les montants, sans toucher aux autres champs (1ère ligne conservée)
        BigDecimal sumNom = getSumNominal(oldEx).add(parse(row.NOMINAL));
        BigDecimal sumEur = getSumNominalEuro(oldEx).add(parse(row.NOMINAL_EURO));
        setSum(oldEx, sumNom, sumEur);

        return oldEx;
    }

    // --------- (C) Finalize : écrit les sommes formatées dans la ligne conservée ----------
    public void finalizeGroup(Exchange exchange) {
        MarginCallSfdhLine kept = exchange.getIn().getBody(MarginCallSfdhLine.class);
        kept.NOMINAL = formatWithComma(getSumNominal(exchange));
        kept.NOMINAL_EURO = formatWithComma(getSumNominalEuro(exchange));
    }

    // ---------------- Helpers proches BW ----------------

    private String remove(String s) {
        if (s == null) return null;
        return s.replaceAll("[^0-9A-Za-z,\\.\\-]", "");
    }

    private String commaToDot(String s) {
        return s == null ? null : s.replace(',', '.');
    }

    private BigDecimal parse(String s) {
        if (s == null || s.isBlank()) return BigDecimal.ZERO;
        String cleaned = remove(s).replace(',', '.').trim();
        if (cleaned.isEmpty() || cleaned.equals(".") || cleaned.equals("-")) return BigDecimal.ZERO;
        return new BigDecimal(cleaned);
    }

    // formatNumber(sum, ",", false()) -> virgule, pas de milliers
    private String formatWithComma(BigDecimal v) {
        if (v == null) v = BigDecimal.ZERO;
        return v.stripTrailingZeros().toPlainString().replace('.', ',');
    }

    private void setSum(Exchange ex, BigDecimal sumNom, BigDecimal sumEur) {
        ex.setProperty(SUM_NOMINAL, sumNom);
        ex.setProperty(SUM_NOMINAL_EUR, sumEur);
    }

    private BigDecimal getSumNominal(Exchange ex) {
        BigDecimal v = (BigDecimal) ex.getProperty(SUM_NOMINAL);
        return v != null ? v : BigDecimal.ZERO;
    }

    private BigDecimal getSumNominalEuro(Exchange ex) {
        BigDecimal v = (BigDecimal) ex.getProperty(SUM_NOMINAL_EUR);
        return v != null ? v : BigDecimal.ZERO;
    }
}


---

Route Camel (lisible)

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat;
import org.springframework.stereotype.Component;

@Component
public class MarginCallRoute extends RouteBuilder {

    private final MarginCallProcessor proc;

    public MarginCallRoute(MarginCallProcessor proc) {
        this.proc = proc;
    }

    @Override
    public void configure() {

        BindyCsvDataFormat inCsv  = new BindyCsvDataFormat(MarginCallCsvLine.class);
        BindyCsvDataFormat outCsv = new BindyCsvDataFormat(MarginCallSfdhLine.class);

        from("file:{{in.dir}}?include=.*\\.csv&noop=true")
            .routeId("margincall-pret-emprunt")
            .unmarshal(inCsv)                 // List<MarginCallCsvLine>
            .split(body())                    // ligne par ligne
                .bean(proc, "map")            // -> MarginCallSfdhLine
                .aggregate(simple("${body.CODE_BOM}"), proc)
                    .completionFromBatchConsumer()  // fin = fin de fichier
                    .bean(proc, "finalizeGroup")
                .end()
            .end()
            .marshal(outCsv)
            .to("file:{{out.dir}}?fileName=${file:name.noext}_AGG.csv");
    }
}


---

Ce que ça reproduit de BW

champs non sommés = 1ère ligne du groupe (current-group()[1])

NOMINAL & NOMINAL_EURO = somme

header input ignoré

séparateur | en sortie


Si tu veux ajouter un header en sortie, dis-moi si tu veux le même header que l’entrée (mêmes libellés).
