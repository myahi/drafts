Oui ✅ 3 classes (2 modèles + 1 bean de traitement) c’est propre et très lisible.

Je te propose ce pattern :

1. MarginCallCsvLine : modèle d’entrée (Bindy, skipFirstLine=true)


2. MarginCallSfdhLine : modèle de sortie (Bindy, séparateur |)


3. MarginCallTransformBean : bean qui fait :

mapping + normalisation (équivalent XSLT)

agrégation “métier” (somme nominal) via Exchange properties




> Et dans la route Camel tu utilises un aggregate() avec une lambda (pas de 4e classe).




---

1) Modèle entrée : MarginCallCsvLine

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

@CsvRecord(separator = "\\|", skipFirstLine = true)
public class MarginCallCsvLine {

    @DataField(pos = 1, required = false)  public String CONTRACT_ID;
    @DataField(pos = 2, required = false)  public String CODE_BOM;
    @DataField(pos = 3, required = false)  public String DIRECTION;
    @DataField(pos = 4, required = false)  public String CURRENCY;

    @DataField(pos = 5, required = false)  public String NOMINAL;
    @DataField(pos = 6, required = false)  public String CLEAN_PRICE;
    @DataField(pos = 7, required = false)  public String ACCRUAL;

    @DataField(pos = 8, required = false)  public String PV_CURRENCY;
    @DataField(pos = 9, required = false)  public String PV_EUR;

    @DataField(pos = 10, required = false) public String PV_HC_CURRENCY;
    @DataField(pos = 11, required = false) public String PV_HC_EUR;

    @DataField(pos = 12, required = false) public String HAIRCUT;
    @DataField(pos = 13, required = false) public String DATE_TRT;
    @DataField(pos = 14, required = false) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15, required = false) public String NOMINAL_EURO;
}


---

2) Modèle sortie : MarginCallSfdhLine

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

@CsvRecord(separator = "\\|", skipFirstLine = false, generateHeaderColumns = false)
public class MarginCallSfdhLine {

    @DataField(pos = 1)  public String CONTRACT_ID;
    @DataField(pos = 2)  public String CODE_BOM;
    @DataField(pos = 3)  public String DIRECTION;
    @DataField(pos = 4)  public String CURRENCY;

    @DataField(pos = 5)  public String NOMINAL;
    @DataField(pos = 6)  public String CLEAN_PRICE;
    @DataField(pos = 7)  public String ACCRUAL;

    @DataField(pos = 8)  public String PV_CURRENCY;
    @DataField(pos = 9)  public String PV_EUR;

    @DataField(pos = 10) public String PV_HC_CURRENCY;
    @DataField(pos = 11) public String PV_HC_EUR;

    @DataField(pos = 12) public String HAIRCUT;
    @DataField(pos = 13) public String DATE_TRT;
    @DataField(pos = 14) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15) public String NOMINAL_EURO;
}


---

3) Bean traitement : MarginCallTransformBean

Il fait :

le mapping + règles BW (remove non alpha, ,→., accrual défaut, etc.)

la somme (stockée dans Exchange properties)

le “finalize” (formatNumber → virgule)


import org.apache.camel.Exchange;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.util.Objects;

@Component
public class MarginCallTransformBean {

    // ---- Normalisation (proche BW) ----
    public String removeAllNonAlphanum(String s) {
        if (s == null) return null;
        return s.replaceAll("[^0-9A-Za-z,\\.\\-]", "");
    }

    public String commaToDot(String s) {
        return s == null ? null : s.replace(',', '.');
    }

    private BigDecimal parseDec(String s) {
        if (s == null || s.isBlank()) return BigDecimal.ZERO;
        String cleaned = removeAllNonAlphanum(s).replace(',', '.').trim();
        if (cleaned.isEmpty() || cleaned.equals(".") || cleaned.equals("-")) return BigDecimal.ZERO;
        return new BigDecimal(cleaned);
    }

    // formatNumber(sum, ",", false()) : sortie avec virgule
    private String formatWithComma(BigDecimal v) {
        if (v == null) v = BigDecimal.ZERO;
        String plain = v.stripTrailingZeros().toPlainString();
        return plain.replace('.', ',');
    }

    // ---- 1) Mapper CSV -> SFDH (équivalent XSLT Map-Data) ----
    public MarginCallSfdhLine mapAndNormalize(MarginCallCsvLine in) {
        MarginCallSfdhLine o = new MarginCallSfdhLine();

        o.CONTRACT_ID = in.CONTRACT_ID;
        o.CODE_BOM    = in.CODE_BOM;
        o.DIRECTION   = in.DIRECTION;
        o.CURRENCY    = in.CURRENCY;

        // NOMINAL : replace(removeAllNon..., ',', '.')
        o.NOMINAL = commaToDot(removeAllNonAlphanum(in.NOMINAL));

        o.CLEAN_PRICE = removeAllNonAlphanum(in.CLEAN_PRICE);

        // ACCRUAL : default "0,0" si vide
        String acc = removeAllNonAlphanum(in.ACCRUAL);
        o.ACCRUAL = (acc != null && !acc.isBlank()) ? acc : "0,0";

        o.PV_CURRENCY = removeAllNonAlphanum(in.PV_CURRENCY);
        o.PV_EUR      = removeAllNonAlphanum(in.PV_EUR);
        o.PV_HC_CURRENCY = removeAllNonAlphanum(in.PV_HC_CURRENCY);
        o.PV_HC_EUR      = removeAllNonAlphanum(in.PV_HC_EUR);
        o.HAIRCUT        = removeAllNonAlphanum(in.HAIRCUT);

        o.DATE_TRT = in.DATE_TRT; // si vide -> restera null
        o.BANKRUPTCY_REMOTE = removeAllNonAlphanum(in.BANKRUPTCY_REMOTE);

        // NOMINAL_EURO : replace(removeAllNon..., ',', '.')
        o.NOMINAL_EURO = commaToDot(removeAllNonAlphanum(in.NOMINAL_EURO));

        return o;
    }

    // ---- 2) Agrégation : initialise ou cumule les sommes ----
    public void initOrAccumulate(Exchange exchange, MarginCallSfdhLine row) {
        BigDecimal sumNom = (BigDecimal) exchange.getProperty("sumNominal");
        BigDecimal sumEur = (BigDecimal) exchange.getProperty("sumNominalEuro");

        if (sumNom == null) sumNom = BigDecimal.ZERO;
        if (sumEur == null) sumEur = BigDecimal.ZERO;

        sumNom = sumNom.add(parseDec(row.NOMINAL));
        sumEur = sumEur.add(parseDec(row.NOMINAL_EURO));

        exchange.setProperty("sumNominal", sumNom);
        exchange.setProperty("sumNominalEuro", sumEur);
    }

    // ---- 3) Finalize : met les sommes formatées dans la ligne agrégée ----
    public void finalizeAggregate(Exchange exchange, MarginCallSfdhLine firstRowKept) {
        BigDecimal sumNom = (BigDecimal) exchange.getProperty("sumNominal");
        BigDecimal sumEur = (BigDecimal) exchange.getProperty("sumNominalEuro");

        firstRowKept.NOMINAL = formatWithComma(sumNom);
        firstRowKept.NOMINAL_EURO = formatWithComma(sumEur);
    }
}


---

Route Camel (squelette) — sans ajouter de classe

Juste pour montrer comment tes 3 classes s’assemblent :

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat;
import org.springframework.stereotype.Component;

@Component
public class MarginCallRoute extends RouteBuilder {

    @Override
    public void configure() {

        BindyCsvDataFormat inCsv  = new BindyCsvDataFormat(MarginCallCsvLine.class);
        BindyCsvDataFormat outCsv = new BindyCsvDataFormat(MarginCallSfdhLine.class);

        from("file:{{in.dir}}?include=.*\\.csv&noop=true")
            .unmarshal(inCsv)                 // List<MarginCallCsvLine>
            .split(body())                    // 1 ligne à la fois
                .bean(MarginCallTransformBean.class, "mapAndNormalize") // -> MarginCallSfdhLine

                .aggregate(simple("${body.CODE_BOM}"), (oldEx, newEx) -> {
                    MarginCallTransformBean bean = newEx.getContext().getRegistry()
                        .lookupByNameAndType("marginCallTransformBean", MarginCallTransformBean.class);

                    MarginCallSfdhLine row = newEx.getIn().getBody(MarginCallSfdhLine.class);

                    if (oldEx == null) {
                        bean.initOrAccumulate(newEx, row);
                        return newEx; // on garde la 1ère ligne du groupe comme “référence”
                    }

                    bean.initOrAccumulate(oldEx, row);
                    return oldEx;
                })
                .completionFromBatchConsumer()
                .process(e -> {
                    MarginCallTransformBean bean = e.getContext().getRegistry()
                        .lookupByNameAndType("marginCallTransformBean", MarginCallTransformBean.class);
                    bean.finalizeAggregate(e, e.getIn().getBody(MarginCallSfdhLine.class));
                })
                .end()
            .end()
            .marshal(outCsv)
            .to("file:{{out.dir}}?fileName=${file:name.noext}_AGG.csv");
    }
}


---

Petite question (pour être carré)

Ton CSV d’entrée a bien 15 colonnes fixes dans le même ordre que ton XSD ?
Si oui, cette approche Bindy est parfaite. Si l’ordre varie, on passera plutôt sur CSV→Map (mais tu garderas quand même 3 classes si tu veux).






Voici un bon point



de départ avec 2 classes :

classe d’entrée (parsing CSV) : tout en String, colonnes optionnelles

classe de sortie (CSV final) : colonnes dans l’ordre, valeurs déjà “propres” (toujours String pour garder le contrôle du format , / .)


> Séparateur CSV : |
Si ton fichier a une ligne d’en-tête, mets skipFirstLine = true (je te laisse les deux options commentées).




---

1) Classe d’entrée : MarginCallCsvLine

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

/**
 * Représente une ligne CSV brute (entrée).
 * Tout en String + required=false => tolérant (équivalent minOccurs=0).
 */
@CsvRecord(
        separator = "\\|",
        skipFirstLine = false // mets true si ton CSV contient un header
)
public class MarginCallCsvLine {

    @DataField(pos = 1, required = false)  public String CONTRACT_ID;
    @DataField(pos = 2, required = false)  public String CODE_BOM;
    @DataField(pos = 3, required = false)  public String DIRECTION;
    @DataField(pos = 4, required = false)  public String CURRENCY;

    @DataField(pos = 5, required = false)  public String NOMINAL;
    @DataField(pos = 6, required = false)  public String CLEAN_PRICE;
    @DataField(pos = 7, required = false)  public String ACCRUAL;

    @DataField(pos = 8, required = false)  public String PV_CURRENCY;
    @DataField(pos = 9, required = false)  public String PV_EUR;

    @DataField(pos = 10, required = false) public String PV_HC_CURRENCY;
    @DataField(pos = 11, required = false) public String PV_HC_EUR;

    @DataField(pos = 12, required = false) public String HAIRCUT;
    @DataField(pos = 13, required = false) public String DATE_TRT;
    @DataField(pos = 14, required = false) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15, required = false) public String NOMINAL_EURO;
}


---

2) Classe de sortie : MarginCallSfdhLine (après mapping + agrégation)

Ici tu peux garder String pour contrôler le rendu final (formatNumber BW → string avec virgule).
Bindy servira à remarshaller vers le CSV résultat.

import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
import org.apache.camel.dataformat.bindy.annotation.DataField;

/**
 * Ligne finale (après mapping + agrégation par CODE_BOM).
 * Les champs sont déjà normalisés + NOMINAL/NOMINAL_EURO déjà sommés/formatés.
 */
@CsvRecord(
        separator = "\\|",
        skipFirstLine = false,
        generateHeaderColumns = false // mets true si tu veux écrire un header
)
public class MarginCallSfdhLine {

    @DataField(pos = 1)  public String CONTRACT_ID;
    @DataField(pos = 2)  public String CODE_BOM;
    @DataField(pos = 3)  public String DIRECTION;
    @DataField(pos = 4)  public String CURRENCY;

    @DataField(pos = 5)  public String NOMINAL;
    @DataField(pos = 6)  public String CLEAN_PRICE;
    @DataField(pos = 7)  public String ACCRUAL;

    @DataField(pos = 8)  public String PV_CURRENCY;
    @DataField(pos = 9)  public String PV_EUR;

    @DataField(pos = 10) public String PV_HC_CURRENCY;
    @DataField(pos = 11) public String PV_HC_EUR;

    @DataField(pos = 12) public String HAIRCUT;
    @DataField(pos = 13) public String DATE_TRT;
    @DataField(pos = 14) public String BANKRUPTCY_REMOTE;

    @DataField(pos = 15) public String NOMINAL_EURO;
}


---

Prochaine étape

Ensuite on écrira :

1. un mapper MarginCallCsvLine -> MarginCallSfdhLine (tes règles BW : remove non alphanum, accrual défaut, virgule/point, etc.)


2. une AggregationStrategy par CODE_BOM qui somme NOMINAL et NOMINAL_EURO.



Dis-moi juste : ton CSV d’entrée a un header ou pas ? (ça change skipFirstLine).
