import org.springframework.web.bind.annotation.GetMapping;
// ...

@GetMapping("/markit/reconnect")
@ResponseBody
public ResponseEntity<ResponseMessage> reconnectMarkit() {
    LOGGER.info("Receive reconnect request");

    try {
        markitApplication.restartConnector();
        return ResponseEntity.status(HttpStatus.OK)
                .body(new ResponseMessage("Markit reconnect triggered"));
    } catch (RuntimeException | ErrorCode e) {
        LOGGER.error("Reconnect failed", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ResponseMessage("Could not reconnect Markit, please check the log files"));
    }
}


j'ai besoin d'exposer un endpoint dans le controller (MarkitController) ci-dessous qui permet de relancer la connexion dans la class LbpMarkitClient
propose moi les modification minimal à apporter pour pouvoir l'exposer ?
package fr.lbp.markit.controller;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import org.apache.commons.lang3.StringUtils;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import fr.lbp.markit.configuration.ApplicationProperties;
import fr.lbp.markit.connection.ErrorCode;
import fr.lbp.markit.tools.ResponseMessage;
import fr.lbp.markit.tools.Tools;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Controller
public class MarkitController {
    private static final Logger LOGGER = LoggerFactory.getLogger(MarkitController.class);

    private final LbpMarkitClient markitApplication;

    // ✅ Spring injecte le singleton LbpMarkitClient (@Component)
    public MarkitController(LbpMarkitClient markitApplication) {
        this.markitApplication = markitApplication;
    }

    @RequestMapping(value = "/restartmarkitconnector")
    @ResponseBody
    public ResponseEntity<ResponseMessage> restartFixConnector() {
        LOGGER.info("Receive restart request");

        try {
            markitApplication.restartConnector();
            return ResponseEntity.status(HttpStatus.OK)
                    .body(new ResponseMessage("Markitdealer connector started !"));
        } catch (RuntimeException | ErrorCode e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    new ResponseMessage("Could not start connector, for more details please check the log files"));
        }
    }

    @RequestMapping(value = "/stopmarkitconnector")
    @ResponseBody
    public ResponseEntity<ResponseMessage> stopFixConnector() {
        LOGGER.info("Receive stop request");
        if (this.markitApplication.isConnected()) {
            try {
                markitApplication.stopMarkitConnector();
            } catch (Exception e) {
                LOGGER.error("", e);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                        new ResponseMessage("Could not stop connector, for more details please check the log files"));
            }
        }
        return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("Markitdealer connector stopped !"));
    }

    @RequestMapping(value = "/statusmarkitconnector")
    @ResponseBody
    public ResponseEntity<ResponseMessage> sessionStatus() {
        if (!this.markitApplication.isConnected()) {
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("Markit session not connected"));
        } else {
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("Markitdealer session connected"));
        }
    }

    @GetMapping("getswdml/{dvh}")
    @ResponseBody
    public ResponseEntity<ResponseMessage> getSWDML(@PathVariable String dvh) {
        LOGGER.info("Receive get SWDML for DVH: {}", dvh);

        if (this.markitApplication.isConnected()) {
            try {
                String swdml = LbpMarkitClient.getDealSWDML(dvh);
                return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(swdml));
            } catch (ErrorCode e) {
                LOGGER.error("",e.getMessage());
                return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE)
                        .body(new ResponseMessage(e.errorString));
            }
        } else {
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("Markitdealer session not connected"));
        }
    }

    @GetMapping("getswml/{dvh}")
    @ResponseBody
    public ResponseEntity<ResponseMessage> getSWML(@PathVariable String dvh) {
        LOGGER.info("Receive get SWML for DVH: {}", dvh);

        if (this.markitApplication.isConnected()) {
            try {
                String swml = LbpMarkitClient.getDealSWML(dvh);
                LOGGER.info("Found SWML {}", swml);
                return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(swml));
            } catch (ErrorCode e) {
            	LOGGER.error("",e);
                return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE)
                        .body(new ResponseMessage(e.errorString));
            }
        } else {
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("Markitdealer session not connected"));
        }
    }

    @RequestMapping(value = "/getLastDVHForTradeId", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> getLastDealsVersionHandles(@RequestParam(value = "tradeId") String tradeId) {
        LOGGER.info("getLastDealsVersionHandles with tradeIds: {}", tradeId);
        String response = "";
        try {
            int dealSide = LbpMarkitClient.getDealGetMySide(Long.valueOf(tradeId));
            LOGGER.info("getLastDealsVersionHandles deal side found: {} for trade id: {}", dealSide, tradeId);

            String[] dvhs = LbpMarkitClient.getAllDealVersionHandles(tradeId, "-1", String.valueOf(dealSide));
            LOGGER.info("getLastDealsVersionHandles dvh found: {} for trade id: {}", String.join(";", dvhs), tradeId);

            if (dvhs != null && dvhs.length > 0) {
                String dvhArray[] = dvhs[0].split(System.lineSeparator());
                LOGGER.info("getLastDealsVersionHandles last dvh found: {} for trade: {}", dvhArray[0], tradeId);
                response += dvhArray[0];
            }

            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));

        } catch (ErrorCode errorCode) {
        	LOGGER.error("",errorCode);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(errorCode.errorString));
        } catch (IOException | NumberFormatException e) {
        	LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/getAllDVHForTradeIdList", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> getAllDealsVersionHandles(
            @RequestParam(value = "tradeIds") String tradeIds,
            @RequestParam(value = "onlyLastDVH") Boolean onlyLastDVH) {

        LOGGER.info("getAllDVHForTradeIdList with tradeIds: {} onlyLastDVH {}", tradeIds, onlyLastDVH);

        String response = "tradeId;dvh\n";
        try {
            for (String currentTradeId : tradeIds.split(";")) {
                int dealSide = LbpMarkitClient.getDealGetMySide(Long.valueOf(currentTradeId));
                LOGGER.info("getAllDVHForTradeIdList deal side found: {} for trade id: {}", dealSide, currentTradeId);

                String[] dvhs = LbpMarkitClient.getAllDealVersionHandles(currentTradeId, "-1", String.valueOf(dealSide));
                LOGGER.info("getAllDVHForTradeIdList dvh found: {} for trade id: {}", String.join(";", dvhs), currentTradeId);

                if (dvhs != null && dvhs.length > 0) {
                    String dvhArray[] = dvhs[0].split(System.lineSeparator());
                    for (String currentDVH : dvhArray) {
                        String currentResponse = currentTradeId + ";" + currentDVH + "\n";
                        response += currentResponse;

                        if (Boolean.TRUE.equals(onlyLastDVH)) {
                            break;
                        }
                    }
                }
            }
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));

        } catch (ErrorCode errorCode) {
            LOGGER.error("",errorCode);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(errorCode.errorString));
        } catch (IOException | NumberFormatException e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/pickupMarkitDeal", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> pickUpMarkitDeal(@RequestParam(value = "tradeIds") String tradeIds) {
        LOGGER.info("pickUpMarkitDeal with tradeIds: {}", tradeIds);

        String response = "tradeId;lastDVH\n";
        String privatDate = "<PrivateData><swTradingBookId>LBPPAR</swTradingBookId></PrivateData>";

        try {
            for (String currentTradeId : tradeIds.split(";")) {
                int dealSide = LbpMarkitClient.getDealGetMySide(Long.valueOf(currentTradeId));
                String[] dvhs = LbpMarkitClient.getAllDealVersionHandles(currentTradeId, "-1", String.valueOf(dealSide));

                if (dvhs != null && dvhs.length > 0) {
                    String dvhArray[] = dvhs[0].split(System.lineSeparator());
                    for (String currentDVH : dvhArray) {
                        String lastDVH = LbpMarkitClient.pickUpDeal(currentDVH, privatDate);
                        String currentResponse = currentTradeId + ";" + lastDVH + "\n";
                        response += currentResponse + "\n";
                    }
                }
            }
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));

        } catch (ErrorCode errorCode) {
            LOGGER.error("",errorCode);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(errorCode.errorString));
        } catch (IOException | NumberFormatException e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/getMyInterestGroups", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> getMyInterestGroups() {
        LOGGER.info("getMyInterestGroups with no parameters");
        try {
            String[] interestGroups = LbpMarkitClient.getMyInterestGroups();
            String interestGroupsList = String.join(";", interestGroups);

            Pattern pattern = Pattern.compile("(<GroupId>)(.*?)(</GroupId>)");
            Matcher matcher = pattern.matcher(interestGroupsList);

            List<String> groupIds = new ArrayList<String>();
            while (matcher.find()) {
                if (null != matcher.group(2) && matcher.group(2).length() > 0) {
                    groupIds.add(matcher.group(2));
                }
            }

            String response = String.join(";", groupIds);
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));

        } catch (ErrorCode errorCode) {
            LOGGER.error("",errorCode);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(errorCode.errorString));
        } catch (NumberFormatException | IOException e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/transferTo", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> transferTo(
            @RequestParam(value = "markitTradeId") String markitTradeId,
            @RequestParam(value = "groupId") String markitGroupId) {

        LOGGER.info("transferTo with markitTradeId: {} to groups: {}", markitTradeId, markitGroupId);

        try {
            String transferRecipientXMLTemplate =
                    "<Recipient id=\"one\"><ParticipantId>#ParticipantId#</ParticipantId><GroupId>#GroupId#</GroupId></Recipient>";

            String[] userInformations = LbpMarkitClient.getMyUserInfo();
            String userInformationAsString = String.join(";", userInformations);

            String participantId = StringUtils.substringBetween(userInformationAsString, "id=\"", "\"");

            int dealSide = LbpMarkitClient.getDealGetMySide(Long.valueOf(markitTradeId));
            String[] dvh = LbpMarkitClient.getAllDealVersionHandles(markitTradeId, "-1", String.valueOf(dealSide));

            if (dvh != null && dvh.length > 0) {
                String lastDVH = dvh[0].split(System.lineSeparator())[0];

                String transferRecipientXML = transferRecipientXMLTemplate.replace("#ParticipantId#", participantId);
                transferRecipientXML = transferRecipientXML.replace("#GroupId#", markitGroupId);

                String newDVH = LbpMarkitClient.transfer(lastDVH, "<PrivateData/>", transferRecipientXML,
                        "Transfert from API to " + markitGroupId);

                String response = "The deal has been successfully transferred, new DVH " + newDVH;
                return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));
            } else {
                return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("No DVH found for the given trade"));
            }

        } catch (ErrorCode | Exception exception) {
            LOGGER.error("",exception);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(exception)));
        }
    }

    @RequestMapping(value = "/transferTov1", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> transferTov1(
            @RequestParam(value = "calypsoTradeId") String calypsoTradeId,
            @RequestParam(value = "calypsoMessageId") String calypsoMessageId,
            @RequestParam(value = "markitDVH") String markitDVH,
            @RequestParam(value = "comment") String comment) {

        LOGGER.info("transferTo with calyspoTradeId: {} and calypsoMessageId: {} and DVH: {} and comment: {}",
                calypsoTradeId, calypsoMessageId, markitDVH, comment);

        try {
            String transferDealTeampleContent =
                    new String(Files.readAllBytes(Paths.get(ApplicationProperties.LBP_MARKIT_TRANSFERDEAL_TEMPLATE_PATH)));

            // ⚠️ Attention: replace() retourne une nouvelle String
            transferDealTeampleContent = transferDealTeampleContent.replace("##calypsoTradeId##", calypsoTradeId);
            transferDealTeampleContent = transferDealTeampleContent.replace("##calypsoMessageId##", calypsoMessageId);
            transferDealTeampleContent = transferDealTeampleContent.replace("##comment##", comment);
            transferDealTeampleContent = transferDealTeampleContent.replace("##markitDVH##", markitDVH);

            String oldDealVersionHandle = Tools.getOldDealVersionHandle(transferDealTeampleContent);
            String privateDataXML = Tools.getPrivateData(transferDealTeampleContent);
            String recipientXML = Tools.getRecipienData(transferDealTeampleContent);

            String newDVH = LbpMarkitClient.transferDeal(oldDealVersionHandle, privateDataXML, recipientXML, comment);

            String response = "The deal has been successfully transferred, new DVH " + newDVH;
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(response));

        } catch (ErrorCode errorCode) {
            LOGGER.error("",errorCode);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(errorCode.errorString));
        } catch (NumberFormatException | IOException e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/isconnected", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> isConnected() {
        LOGGER.debug("received session check");
        try {
            String result = LbpMarkitClient.IS_MARKIT_SESSION_CONNECTED
                    ? "markitdealer session connected"
                    : "markitdealer session not connected";
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage(result));
        } catch (Exception e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }

    @RequestMapping(value = "/loggedout", method = RequestMethod.GET)
    @ResponseBody
    public ResponseEntity<ResponseMessage> loggedout() {
        LOGGER.debug("received loggedout");
        try {
            markitApplication.stopMarkitConnector();
            return ResponseEntity.status(HttpStatus.OK).body(new ResponseMessage("client is loggedout"));
        } catch (Exception e) {
            LOGGER.error("",e);
            return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE).body(new ResponseMessage(stacktrace(e)));
        }
    }


    private static String stacktrace(Throwable t) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        t.printStackTrace(pw);
        return sw.toString();
    }
  }


voici le code de la classe LbpMarkitClient
package fr.lbp.markit.controller;

import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_CONNECTION_TESTDURATION;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_CONNECTION_TIMEOUT;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_MAX_RETRY_COUNT;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_PASSWORD;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_PORT;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_USER_NAME;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKTI_HOST_NAME;
import static fr.lbp.markit.configuration.ApplicationProperties.LBP_MARKIT_EMAIL_ALERT_THRESHOLD;

import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

import javax.jms.JMSException;


import org.springframework.boot.SpringApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.stereotype.Component;

import com.swapswire.sw_api.SWAPILinkModule;

import fr.lbp.jms.connection.JMSListener;
import fr.lbp.markit.alerting.MarkitMailService;
import fr.lbp.markit.connection.DealerAPIWrapper;
import fr.lbp.markit.connection.ErrorCode;
import fr.lbp.markit.connection.Session;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


@Component
public class LbpMarkitClient {

    private final MarkitMailService mailService;

    private static volatile LbpMarkitClient INSTANCE;

    private static final Logger LOGGER = LoggerFactory.getLogger(LbpMarkitClient.class);
    
    

    // ---- Locks
    private static final Object SESSION_LOCK = new Object();
    private static final Object EXECUTOR_LOCK = new Object();

    // ---- Etat global
    private static volatile Session MARKIT_SESSION;
    private static final AtomicInteger CURRENT_CONNECTION_ERROR_COUNT = new AtomicInteger(0);

    public static volatile boolean IS_MARKIT_SESSION_CONNECTED = false;
    public static volatile boolean DISCONNECTION_REQUEST_RECEIVED = false;

    private final int maxConnectionRetryCount = LBP_MARKIT_MAX_RETRY_COUNT;

    private static ExecutorService executorService;

    // ---- Non static
    private JMSListener jmsListner;

    private static volatile Thread MARKIT_WORKER_THREAD;

    private static final AtomicBoolean MAX_RETRY_ALERT_SENT = new AtomicBoolean(false);
    private static final AtomicBoolean EMAIL_SENT = new AtomicBoolean(false);

    private static volatile ConfigurableApplicationContext APP_CONTEXT;

    private static final AtomicBoolean STOP_ONCE = new AtomicBoolean(false);
    private static final AtomicBoolean SHUTDOWN_ONCE = new AtomicBoolean(false);

    static {
        System.load(System.getenv("LD_LIBRARY_PATH_SO"));
    }

    /**
     * A appeler depuis le main :
     *   ConfigurableApplicationContext ctx = SpringApplication.run(...);
     *   LbpMarkitClient.setApplicationContext(ctx);
     */
    public static void setApplicationContext(ConfigurableApplicationContext ctx) {
        APP_CONTEXT = ctx;
    }

    public LbpMarkitClient(MarkitMailService mailService) {
        this.mailService = mailService;
        INSTANCE = this;
        try {
            this.initializeMarkitConnector(false);
            DISCONNECTION_REQUEST_RECEIVED = false;
        } catch (JMSException | ErrorCode e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    public boolean isConnected() {
        return IS_MARKIT_SESSION_CONNECTED;
    }

    public boolean isMarkitSessionConnected() {
        Session s = getSession();
        return s != null && s.isValidClientSession();
    }

    public void initializeMarkitConnector(boolean resetRetryCount) throws JMSException, ErrorCode {
        LOGGER.info("initialize MarkitConnector with count error count: {}", CURRENT_CONNECTION_ERROR_COUNT.get());

        if (resetRetryCount) {
            CURRENT_CONNECTION_ERROR_COUNT.set(0);
            DISCONNECTION_REQUEST_RECEIVED = false;
            MAX_RETRY_ALERT_SENT.set(false);
            EMAIL_SENT.set(false);

            // ✅ reset des garde-fous pour un restart
            STOP_ONCE.set(false);
            SHUTDOWN_ONCE.set(false);
        }

        if (IS_MARKIT_SESSION_CONNECTED || DISCONNECTION_REQUEST_RECEIVED) {
            if (IS_MARKIT_SESSION_CONNECTED) {
                LOGGER.warn("Markit dealer connector already started");
            }
            return;
        }

        synchronized (EXECUTOR_LOCK) {
            if (executorService == null || executorService.isShutdown()) {
                executorService = Executors.newSingleThreadExecutor();
            }
        }

        if (jmsListner == null) {
            jmsListner = new JMSListener();
        }

        String[] libraryVersion = { new String() };
        LOGGER.info("SW_API_DLL Version = {}", libraryVersion[0]);

        final String markitHost = LBP_MARKTI_HOST_NAME;
        final String markitPort = LBP_MARKIT_PORT;
        final String markitUserName = LBP_MARKIT_USER_NAME;
        final String markitPassword = LBP_MARKIT_PASSWORD;
        final int timeoutMs = LBP_MARKIT_CONNECTION_TIMEOUT;

        final Supplier<Session> sessionFactory = () -> new Session(
                markitHost + ":" + markitPort,
                markitUserName,
                markitPassword,
                timeoutMs
        );

        executorService.execute(() -> {
            MARKIT_WORKER_THREAD = Thread.currentThread();

            Session currentSession = sessionFactory.get();

            while (!DISCONNECTION_REQUEST_RECEIVED
                    && CURRENT_CONNECTION_ERROR_COUNT.get() < maxConnectionRetryCount
                    && !Thread.currentThread().isInterrupted()) {

                try {
                    DealerAPIWrapper.poll(LBP_MARKIT_CONNECTION_TESTDURATION, LBP_MARKIT_CONNECTION_TIMEOUT);

                    // Healthcheck "léger" : si connecté, on vérifie la session via une call
                    Session s = getSession();
                    if (s != null && IS_MARKIT_SESSION_CONNECTED && !DISCONNECTION_REQUEST_RECEIVED) {
                        String[] books = { new String() };
                        DealerAPIWrapper.getBookList(s.getLoginHandle(), books);

                        IS_MARKIT_SESSION_CONNECTED = true;
                        CURRENT_CONNECTION_ERROR_COUNT.set(0);
                        MAX_RETRY_ALERT_SENT.set(false);
                    }

                    // Connexion si pas connecté
                    if (!IS_MARKIT_SESSION_CONNECTED && !DISCONNECTION_REQUEST_RECEIVED) {
                        try {
                            currentSession.disconnect();
                        } catch (Exception toIgnore) {
                            // ignore
                        }

                        currentSession.connect();

                        if (!currentSession.isValidClientSession()) {
                            LOGGER.warn("Session invalid after connect/login: forcing retry");
                            throw new ErrorCode(SWAPILinkModule.SWERR_Timeout);
                        }

                        if (jmsListner != null) {
                            jmsListner.startListening();
                            currentSession.setMessageHandler(jmsListner.getIncomingService());
                        }

                        setSession(currentSession);
                        IS_MARKIT_SESSION_CONNECTED = true;
                        CURRENT_CONNECTION_ERROR_COUNT.set(0);
                        MAX_RETRY_ALERT_SENT.set(false);
                    }

                } catch (ErrorCode err) {
                    // Cookie rejeté => on reconstruit la Session
                    if (isCookieRejected(err)) {
                        LOGGER.warn("Cookie rejected (-301): rebuilding Session from scratch");
                        try {
                            currentSession.disconnect();
                        } catch (Exception toIgnore) {
                            // ignore
                        }
                        setSession(null);
                        IS_MARKIT_SESSION_CONNECTED = false;
                        currentSession = sessionFactory.get();
                    }

                    handleConnectionIssue(err);

                    // backoff si on doit retenter
                    if (!DISCONNECTION_REQUEST_RECEIVED
                            && CURRENT_CONNECTION_ERROR_COUNT.get() < maxConnectionRetryCount) {
                        try {
                            Thread.sleep(5000L);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                }
            }

            // ✅ IMPORTANT: on ne refait PAS stop/shutdown ici (déjà géré dans handleConnectionIssue)
            // Si on sort de boucle parce qu'on nous a demandé d'arrêter, stopMarkitConnectorInternal()
            // sera appelé par le flux d'arrêt (ou déjà fait).
        });
    }

    private void handleConnectionIssue(ErrorCode err) {
        int attempt = CURRENT_CONNECTION_ERROR_COUNT.incrementAndGet();

        LOGGER.error("Exception occurred while trying connection retry attempt {}", attempt);
        LOGGER.error("",err);

        IS_MARKIT_SESSION_CONNECTED = false;

        if (attempt >= maxConnectionRetryCount) {
            LOGGER.error("Maximum try number has been reached");

            if (MAX_RETRY_ALERT_SENT.compareAndSet(false, true)) {
                try {
                    Date currentDate = new Date();
                    DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
                    if (jmsListner != null) {
                        jmsListner.send(
                                JMSListener.OutgoingType.TECHNICAL_ERROR,
                                dateFormat.format(currentDate)
                                        + ": Le nombre de tentative de connexion a été atteint sur le connecteur markitdealer\n"
                                        + " le connecteur a été arrété."
                        );
                    }
                } catch (Exception e) {
                    LOGGER.error("Failed to send functional alert (ignored)", e);
                }
            }

            stopMarkitConnectorInternal();
            requestApplicationShutdown(2);
            return;
        }

        // Alerte email au-delà du threshold
        int threshold = LBP_MARKIT_EMAIL_ALERT_THRESHOLD;
        if (attempt >= threshold && EMAIL_SENT.compareAndSet(false, true)) {
            try {
                mailService.send(
                        "MarkitDealer",
                        "Bonjour,<br> une alerte de perturbation de connexion vers Markitdealer a été remontée <br>Veuillez contacter l'équipe support."
                );
            } catch (Exception e) {
                LOGGER.error("Email alert failed (ignored)", e);
            }
        }

        LOGGER.info("Current connection retry count: {}", attempt);
        LOGGER.info("Max connection retry count: {}", maxConnectionRetryCount);
    }


    private void requestApplicationShutdown(int exitCode) {
        if (!SHUTDOWN_ONCE.compareAndSet(false, true)) return;

        final ConfigurableApplicationContext ctx = APP_CONTEXT;
        if (ctx == null) {
            System.err.println("APP_CONTEXT null -> forcing halt(" + exitCode + ")");
            Runtime.getRuntime().halt(exitCode);
            return;
        }

        Thread watchdog = new Thread(() -> {
            try {
                Thread.sleep(8000); // 8s
                System.err.println("Shutdown stuck -> forcing halt(" + exitCode + ")");
                Runtime.getRuntime().halt(exitCode);
            } catch (InterruptedException ignored) {}
        }, "shutdown-watchdog");
        watchdog.setDaemon(true);
        watchdog.start();

        new Thread(() -> {
            try {
                System.err.println("Shutting down Spring (exitCode=" + exitCode + ")");
                int code = SpringApplication.exit(ctx, () -> exitCode);
                System.exit(code);
            } catch (Throwable t) {
                System.err.println("Shutdown failed -> forcing halt(" + exitCode + "): " + t);
                Runtime.getRuntime().halt(exitCode);
            }
        }, "markit-shutdown").start();
    }

    public static void loggedOut() throws ErrorCode {
        Session s = getSession();
        if (s != null) {
            DealerAPIWrapper.logout(s.getLoginHandle());
        }
        DISCONNECTION_REQUEST_RECEIVED = true;
        IS_MARKIT_SESSION_CONNECTED = false;
    }

    public void stopMarkitConnector() {
        if (INSTANCE != null) {
            INSTANCE.stopMarkitConnectorInternal();
        } else {
            DISCONNECTION_REQUEST_RECEIVED = true;
            IS_MARKIT_SESSION_CONNECTED = false;
            synchronized (EXECUTOR_LOCK) {
                if (executorService != null) {
                    executorService.shutdown();
                    try {
                        executorService.awaitTermination(5, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    executorService = null;
                }
            }
        }
    }

    private void stopMarkitConnectorInternal() {
        // ✅ NEW: stop idempotent -> évite logs doublés
        if (!STOP_ONCE.compareAndSet(false, true)) {
            return;
        }

        DISCONNECTION_REQUEST_RECEIVED = true;
        IS_MARKIT_SESSION_CONNECTED = false;

        try {
            if (jmsListner != null) {
                jmsListner.stopListening();
            }
        } catch (Exception e) {
            LOGGER.error("stopListening failed (ignored)", e);
        }

        try {
            Session session = getSession();
            if (session != null) {
                try {
                    DealerAPIWrapper.logout(session.getLoginHandle());
                    LOGGER.info("Session logout");
                } catch (ErrorCode e) {
                    LOGGER.warn("logout failed (ignored): {}", safeMsg(e));
                } catch (Exception e) {
                    LOGGER.warn("logout failed (ignored): {}", safeMsg(e));
                }
            }
        } catch (Exception e) {
            LOGGER.error("stopMarkitConnectorInternal session cleanup failed (ignored)", e);
        } finally {
            setSession(null);
        }

        // ⚠️ éviter deadlock: ne pas shutdown l'executor depuis le worker lui-même
        if (Thread.currentThread() == MARKIT_WORKER_THREAD) {
            LOGGER.info("Stop requested from Markit worker thread: skipping executor shutdown/await.");
            return;
        }

        synchronized (EXECUTOR_LOCK) {
            if (executorService != null) {
                executorService.shutdown();
                try {
                    executorService.awaitTermination(5, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                executorService = null;
            }
        }

        LOGGER.info("Markit connection stopped");
    }

    public synchronized void restartConnector() throws ErrorCode {
        try {
            try {
                if (IS_MARKIT_SESSION_CONNECTED) {
                    stopMarkitConnector();
                }
            } catch (Exception ignore) {
                // ignore
            }

            DISCONNECTION_REQUEST_RECEIVED = false;
            IS_MARKIT_SESSION_CONNECTED = false;

            CURRENT_CONNECTION_ERROR_COUNT.set(0);
            MAX_RETRY_ALERT_SENT.set(false);
            EMAIL_SENT.set(false);

            // ✅ reset pour que stop/shutdown puissent repartir
            STOP_ONCE.set(false);
            SHUTDOWN_ONCE.set(false);

            initializeMarkitConnector(true);

            LOGGER.info("Restart Markit connection in progress...");
        } catch (Exception e) {
            LOGGER.error("restartConnector failed", e);
            throw new RuntimeException("restartConnector failed: " + e.getMessage(), e);
        }
    }

    private static Session getSession() {
        synchronized (SESSION_LOCK) {
            return MARKIT_SESSION;
        }
    }

    private static void setSession(Session s) {
        synchronized (SESSION_LOCK) {
            MARKIT_SESSION = s;
        }
    }

    private static boolean isCookieRejected(ErrorCode err) {
        return err != null && err.errorCode == -301;
    }

    private static String safeMsg(Object e) {
        if (e == null) return "null";
        try {
            if (e instanceof Throwable) {
                String m = ((Throwable) e).getMessage();
                if (m != null && !m.trim().isEmpty()) return m;
            }
            return String.valueOf(e);
        } catch (Exception ex) {
            return String.valueOf(e);
        }
    }

    // --------------------------------------------------------------------
    // Méthodes métiers : signatures inchangées, session lue thread-safe
    // --------------------------------------------------------------------

    public static String[] getAllDealVersionHandles(String tradeId, String contractVersion, String side)
            throws NumberFormatException, ErrorCode {
        String[] dealVersionHandles = { new String() };
        Session s = getSession();
        if (s == null) return dealVersionHandles;
        DealerAPIWrapper.getAllDealVersionHandles(s.getLoginHandle(),
                Long.valueOf(tradeId),
                Integer.valueOf(contractVersion),
                Integer.valueOf(side),
                dealVersionHandles);
        return dealVersionHandles;
    }

    public static String getSWDML(String dealVersionHandle, String privateDataXML, String recipientXML, String messageText)
            throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.getDealSWDML(s.getLoginHandle(), "SWDML_4_2: 4.2", dealVersionHandle, newDealVersionHandle);
            LOGGER.info("Deal Submitted To Markit {}", newDealVersionHandle[0]);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String submitNewDeal(String swdml, String privateDataXML, String recipientXML, String messageText)
            throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.submitNewDeal(s.getLoginHandle(), swdml, privateDataXML, recipientXML, messageText, newDealVersionHandle);
            LOGGER.info("Deal Submitted To Markit {}", newDealVersionHandle[0]);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String submitDraftNewDeal(String swdml, String privateDataXML, String recipientXML, String messageText)
            throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.submitDraftNewDeal(s.getLoginHandle(), swdml, privateDataXML, recipientXML, messageText, newDealVersionHandle);
            LOGGER.info("Draft deal submitted To Markit {}", newDealVersionHandle[0]);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String releaseDeal(String privateDataXML, String oldDealVersionHandle) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.release(s.getLoginHandle(), oldDealVersionHandle, privateDataXML, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String cancelDeal(String privateDataXML, String oldDealVersionHandle) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.release(s.getLoginHandle(), oldDealVersionHandle, privateDataXML, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String rejectDeal(String oldDealVersionHandle, String messageText) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.rejectDK(s.getLoginHandle(), oldDealVersionHandle, messageText, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String transferDeal(String oldDealVersionHandle, String privateDataXML, String recipientXML, String messageText)
            throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.transfer(s.getLoginHandle(), oldDealVersionHandle, privateDataXML, recipientXML, messageText, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String updateDeal(String oldDealVersionHandle, String sinkUpdateXML) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.update(s.getLoginHandle(), oldDealVersionHandle, sinkUpdateXML, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String submitPostTradeEvent(String privateDataXML, String oldDealVersionHandle, String postTradeXML,
                                             String recipientXML, String messageText) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.submitPostTradeEvent(s.getLoginHandle(), oldDealVersionHandle, postTradeXML, privateDataXML,
                    recipientXML, messageText, newDealVersionHandle);
            return newDealVersionHandle[0];
        }
        return null;
    }

    public static String pickUpDeal(String oldDealVersionHandle, String privateDataXML) throws IOException, ErrorCode {
        String[] newDealVersionHandleForPickUp = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.pickup(s.getLoginHandle(), oldDealVersionHandle, privateDataXML, newDealVersionHandleForPickUp);
            return newDealVersionHandleForPickUp[0];
        }
        return null;
    }

    public static String affirmDeal(String oldDealVersionHandle, String privateDataXML, String swdml)
            throws IOException, ErrorCode {
        String[] newDealVersionHandleForAffirm = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            LOGGER.info("Sending affirm for DVH: {}", oldDealVersionHandle);
            DealerAPIWrapper.affirm(s.getLoginHandle(), oldDealVersionHandle, swdml, privateDataXML,
                    "AFFIRM FROM API CLIENT", newDealVersionHandleForAffirm);
            return newDealVersionHandleForAffirm[0];
        }
        return null;
    }

    public static String acceptAffirmDeal(String oldDealVersionHandle, String privateDataXML)
            throws IOException, ErrorCode {
        String[] newDealVersionHandleForAcceptAffirm = { new String() };
        Session s = getSession();
        if (s != null && s.isValidClientSession()) {
            DealerAPIWrapper.acceptAffirm(s.getLoginHandle(), oldDealVersionHandle, privateDataXML, newDealVersionHandleForAcceptAffirm);
            return newDealVersionHandleForAcceptAffirm[0];
        }
        return null;
    }

    public static String transfer(String oldDealVersionHandle, String privateDataXML,
                                  String transferRecipientXML, String messageText) throws IOException, ErrorCode {
        String[] newDealVersionHandle = { new String() };
        Session session = getSession();
        if (session == null) return null;
        DealerAPIWrapper.transfer(session.getLoginHandle(), oldDealVersionHandle, privateDataXML,
                transferRecipientXML, messageText, newDealVersionHandle);
        LOGGER.info("Draft deal submitted To Markit {}", newDealVersionHandle[0]);
        return newDealVersionHandle[0];
    }

    public static String[] getMyInterestGroups() throws IOException, ErrorCode {
        String[] resultXML = { new String() };
        Session session = getSession();
        if (session == null) return resultXML;
        DealerAPIWrapper.getMyInterestGroups(session.getLoginHandle(), resultXML);
        LOGGER.info("Get my InterestGroups {}", String.join(";", resultXML));
        return resultXML;
    }

    public static String[] getMyUserInfo() throws IOException, ErrorCode {
        String[] resultXML = { new String() };
        Session session = getSession();
        if (session == null) return resultXML;
        DealerAPIWrapper.getMyuserInfo(session.getLoginHandle(), resultXML);
        LOGGER.info("Get my user informations {}", String.join(";", resultXML));
        return resultXML;
    }

    public static int getDealGetMySide(long dealId) throws IOException, ErrorCode {
        int[] side_out = { Integer.valueOf(1) };
        Session session = getSession();
        if (session == null) return side_out[0];
        DealerAPIWrapper.getDealGetMySide(session.getLoginHandle(), dealId, side_out);
        LOGGER.info("getDealGetMySide for trade Id : {} {}", dealId, side_out[0]);
        return side_out[0];
    }

    public static String[] queryDeals(String queryXML) throws IOException, ErrorCode {
        String[] resultsXML = { new String() };
        Session session = getSession();
        if (session == null) return resultsXML;
        DealerAPIWrapper.queryDeals(session.getLoginHandle(), queryXML, resultsXML);
        for (String result : resultsXML) {
            LOGGER.info("Query deals result: {}", result);
        }
        return resultsXML;
    }

    public static String getDealSWML(String dealVersionHandle) throws ErrorCode {
        String[] swdml = { new String() };
        Session session = getSession();
        if (session == null) return null;
        DealerAPIWrapper.getDealSWML(session.getLoginHandle(), "4.2", dealVersionHandle, swdml);
        return swdml[0];
    }

    public static String getDealSWDML(String dealVersionHandle) throws ErrorCode {
        String[] swdml = { new String() };
        Session session = getSession();
        if (session == null) return null;
        DealerAPIWrapper.getDealSWDML(session.getLoginHandle(), "4.2", dealVersionHandle, swdml);
        return swdml[0];
    }

    public static String withdrawDeal(String dealVersionHandle, String privateDataXML) throws ErrorCode {
        Session session = getSession();
        if (session == null) return null;

        String[] newDealVersionHandleForPull = { new String() };
        DealerAPIWrapper.pull(session.getLoginHandle(), dealVersionHandle, newDealVersionHandleForPull);

        String[] newDealVersionHandleForWithdraw = { new String() };
        DealerAPIWrapper.withdraw(session.getLoginHandle(), newDealVersionHandleForPull[0], newDealVersionHandleForWithdraw);
        return newDealVersionHandleForWithdraw[0];
    }
              } 
