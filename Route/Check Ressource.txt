
Oui ğŸ‘ on peut faire EXACTEMENT la mÃªme chose que les 2 classes, mais en une seule classe, sans perdre de fonctionnalitÃ©.

Voici la version recommandÃ©e â€œ1 classe = 2 classes fusionnÃ©esâ€, qui fait strictement la mÃªme chose que :

CriticalResourceChecker

StartupAndRuntimeGuard



---

âœ… Une seule classe : CriticalResourcesGuard

ğŸ‘‰ Elle fait :

check Oracle + EMS + FS

retry + dÃ©lai paramÃ©trables

check au dÃ©marrage

check pÃ©riodique

arrÃªt complet de lâ€™application si KO

compatible avec ton dÃ©marrage contrÃ´lÃ© des routes



---

CriticalResourcesGuard.java

@Component
@EnableScheduling
public class CriticalResourcesGuard {

  private final JdbcTemplate jdbc;
  private final Environment env;
  private final ApplicationContext ctx;

  public CriticalResourcesGuard(JdbcTemplate jdbc,
                                Environment env,
                                ApplicationContext ctx) {
    this.jdbc = jdbc;
    this.env = env;
    this.ctx = ctx;
  }

  /* =========================
     DÃ‰MARRAGE APPLICATION
     ========================= */
  @EventListener(ApplicationReadyEvent.class)
  public void checkOnStartup() {
    int retries = env.getProperty("resource.check.retry.count", Integer.class, 3);
    long delayMs = env.getProperty("resource.check.retry.delay-ms", Long.class, 5000L);

    for (int i = 1; i <= retries; i++) {
      try {
        checkAll();
        return; // âœ… OK â†’ les routes pourront dÃ©marrer
      } catch (Exception e) {
        if (i == retries) {
          shutdown("Startup resource check failed", e);
        }
        sleep(delayMs);
      }
    }
  }

  /* =========================
     SURVEILLANCE RUNTIME
     ========================= */
  @Scheduled(fixedDelayString = "${resource.check.period-ms}")
  public void periodicCheck() {
    try {
      checkAll();
    } catch (Exception e) {
      shutdown("Runtime resource failure", e);
    }
  }

  /* =========================
     CHECKS
     ========================= */
  private void checkAll() {
    checkOracle();
    checkEms();
    checkFilesystem();
  }

  private void checkOracle() {
    jdbc.queryForObject("select 1 from dual", Integer.class);
  }

  private void checkEms() {
    try {
      var factory = new com.tibco.tibjms.TibjmsConnectionFactory(
        env.getRequiredProperty("resource.ems.url")
      );
      try (var c = factory.createConnection(
          env.getRequiredProperty("resource.ems.user"),
          env.getRequiredProperty("resource.ems.password"))) {
        c.start();
      }
    } catch (Exception e) {
      throw new IllegalStateException("EMS unavailable", e);
    }
  }

  private void checkFilesystem() {
    Path path = Paths.get(env.getRequiredProperty("resource.fs.path"));
    if (!Files.isDirectory(path) || !Files.isReadable(path)) {
      throw new IllegalStateException("Filesystem not accessible: " + path);
    }
  }

  /* =========================
     ARRÃŠT APPLICATION
     ========================= */
  private void shutdown(String reason, Exception e) {
    // log.error(reason, e);
    SpringApplication.exit(ctx, () -> 1);
    System.exit(1);
  }

  private void sleep(long ms) {
    try {
      Thread.sleep(ms);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
    }
  }
}


---

âœ… application.properties (inchangÃ©)

resource.check.retry.count=5
resource.check.retry.delay-ms=5000
resource.check.period-ms=60000

resource.fs.path=/data/camel/input

resource.ems.url=tcp://ems.mycompany.local:7222
resource.ems.user=ems_user
resource.ems.password=secret


---

ğŸ§© Comment Ã§a sâ€™intÃ¨gre avec ton existant

1. Spring dÃ©marre


2. ApplicationReadyEvent


3. ğŸ” check ressources


4. âŒ KO â†’ app stoppÃ©e


5. âœ… OK â†’ ton RouteStartupManager dÃ©marre Camel + routes


6. En runtime â†’ check pÃ©riodique


7. Ressource KO â†’ app stoppÃ©e




---

TL;DR

âœ”ï¸ 1 seule classe
âœ”ï¸ mÃªme comportement que les 2 prÃ©cÃ©dentes
âœ”ï¸ plus simple Ã  lire / maintenir
âœ”ï¸ parfaitement alignÃ© avec Spring Boot 3 + Camel

Si tu veux, je peux te proposer une variante :

qui stoppe seulement Camel au lieu de tuer lâ€™app

ou qui publie un status Actuator readiness plutÃ´t que System.exit

*****

OK ğŸ‘ je te propose une solution propre, robuste et minimale, alignÃ©e avec ce que tu as dÃ©jÃ  :

âœ… avant dÃ©marrage des routes

âœ… vÃ©rifications : Oracle / TIBCO EMS / filesystem

âœ… retry + dÃ©lai paramÃ©trables

âœ… vÃ©rification pÃ©riodique

âœ… si KO â†’ arrÃªt de lâ€™application

âœ… minimum de classes (2)



---

ğŸ§  Principe global (important)

1. Au dÃ©marrage

on vÃ©rifie les 3 ressources

avec retry + dÃ©lai

âŒ si toujours KO â†’ on stoppe lâ€™application

âœ… si OK â†’ on dÃ©marre Camel + routes (comme tu as dÃ©jÃ )



2. En runtime (pÃ©riodique)

on recheck toutes les X secondes

âŒ si une ressource devient KO â†’ on stoppe lâ€™application




ğŸ‘‰ On ne stoppe pas juste les routes : on tue lâ€™app
(câ€™est ce que tu as demandÃ©, et câ€™est cohÃ©rent en prod).


---

1ï¸âƒ£ application.properties

### Health check
resource.check.retry.count=5
resource.check.retry.delay-ms=5000
resource.check.period-ms=60000

### Filesystem
resource.fs.path=/data/camel/input

### TIBCO EMS
resource.ems.url=tcp://ems.mycompany.local:7222
resource.ems.user=ems_user
resource.ems.password=secret


---

2ï¸âƒ£ Classe 1 â€” CriticalResourceChecker (le cÅ“ur)

ğŸ‘‰ UNE SEULE classe pour les 3 checks + retry

@Component
public class CriticalResourceChecker {

  private final JdbcTemplate jdbc;
  private final Environment env;

  public CriticalResourceChecker(JdbcTemplate jdbc, Environment env) {
    this.jdbc = jdbc;
    this.env = env;
  }

  public void checkAllOrFail() {
    checkOracle();
    checkEms();
    checkFileSystem();
  }

  private void checkOracle() {
    jdbc.queryForObject("select 1 from dual", Integer.class);
  }

  private void checkEms() {
    try {
      String url = env.getRequiredProperty("resource.ems.url");
      String user = env.getRequiredProperty("resource.ems.user");
      String pwd = env.getRequiredProperty("resource.ems.password");

      var factory = new com.tibco.tibjms.TibjmsConnectionFactory(url);
      try (var connection = factory.createConnection(user, pwd)) {
        connection.start();
      }
    } catch (Exception e) {
      throw new IllegalStateException("EMS unavailable", e);
    }
  }

  private void checkFileSystem() {
    Path path = Paths.get(env.getRequiredProperty("resource.fs.path"));
    if (!Files.isDirectory(path) || !Files.isReadable(path)) {
      throw new IllegalStateException("Filesystem not accessible: " + path);
    }
  }
}


---

3ï¸âƒ£ Classe 2 â€” StartupAndRuntimeGuard

ğŸ‘‰ 1 classe pour :

retry au dÃ©marrage

check pÃ©riodique

arrÃªt de lâ€™application


@Component
public class StartupAndRuntimeGuard {

  private final CriticalResourceChecker checker;
  private final ApplicationContext context;
  private final Environment env;

  public StartupAndRuntimeGuard(CriticalResourceChecker checker,
                                ApplicationContext context,
                                Environment env) {
    this.checker = checker;
    this.context = context;
    this.env = env;
  }

  @EventListener(ApplicationReadyEvent.class)
  public void initialCheck() {
    int retries = env.getProperty("resource.check.retry.count", Integer.class, 3);
    long delay = env.getProperty("resource.check.retry.delay-ms", Long.class, 5000L);

    for (int i = 1; i <= retries; i++) {
      try {
        checker.checkAllOrFail();
        return; // âœ… OK
      } catch (Exception e) {
        if (i == retries) {
          shutdown("Startup check failed", e);
        }
        sleep(delay);
      }
    }
  }

  @Scheduled(fixedDelayString = "${resource.check.period-ms}")
  public void periodicCheck() {
    try {
      checker.checkAllOrFail();
    } catch (Exception e) {
      shutdown("Runtime resource failure", e);
    }
  }

  private void shutdown(String reason, Exception e) {
    // log.error(reason, e);
    SpringApplication.exit(context, () -> 1);
    System.exit(1);
  }

  private void sleep(long ms) {
    try {
      Thread.sleep(ms);
    } catch (InterruptedException ignored) {
      Thread.currentThread().interrupt();
    }
  }
}

âš ï¸ Nâ€™oublie pas :

@EnableScheduling


---

4ï¸âƒ£ Ordre rÃ©el au dÃ©marrage (important)

1. Spring dÃ©marre


2. ApplicationReadyEvent


3. ğŸ” check Oracle / EMS / FS


4. âŒ KO â†’ app arrÃªtÃ©e


5. âœ… OK â†’ ton RouteStartupManager dÃ©marre Camel + routes



ğŸ‘‰ Aucune route ne dÃ©marre tant que les ressources ne sont pas OK


---

âœ… Ce que tu obtiens

âœ”ï¸ 2 classes seulement
âœ”ï¸ checks critiques centralisÃ©s
âœ”ï¸ retry + dÃ©lai paramÃ©trables
âœ”ï¸ surveillance continue
âœ”ï¸ arrÃªt net et propre
âœ”ï¸ cohÃ©rent avec Camel + Hawtio + DB state


---

TL;DR

> Avant routes â†’ check ressources
Pendant runtime â†’ recheck pÃ©riodique
KO â†’ application stoppÃ©e



Si tu veux, au prochain message je peux te donner :

la version non bloquante (stop routes au lieu de kill app)

lâ€™intÃ©gration Actuator readiness

ou une version testable (mock EMS / FS / DB) 
