Parfait, merci pour le code üëç
Je te fais les adaptations minimales et propres, sans tout r√©inventer, en respectant ce que tu veux :

gestion par instance

persister seulement le runtime (Hawtio)

Oracle

option 1 (autoStartup(false))

suppression d‚ÄôApplicationRunner



---

1Ô∏è‚É£ Adaptation du mod√®le Oracle (par instance)

Nouvelle table

create table CAMEL_ROUTE_STATE (
  INSTANCE_NAME varchar2(128) not null,
  ROUTE_ID varchar2(255) not null,
  DESIRED_STATE varchar2(16) not null,
  UPDATED_AT timestamp not null,
  constraint PK_CAMEL_ROUTE_STATE
    primary key (INSTANCE_NAME, ROUTE_ID)
);


---

2Ô∏è‚É£ Bean instanceName (fail fast)

@Bean
String instanceName(Environment env) {
  return env.getRequiredProperty("app.instance-name");
}

Lancement :

java -jar app.jar --app.instance-name=instance-1


---

3Ô∏è‚É£ Flag de readiness (runtime only)

@Component
public class AppReadiness {

  private volatile boolean ready = false;

  @EventListener(ApplicationReadyEvent.class)
  public void onReady() {
    ready = true;
  }

  public boolean isReady() {
    return ready;
  }
}


---

4Ô∏è‚É£ RouteStateEventNotifier (runtime only + instance)

üîÅ Modifi√©

@Component
public class RouteStateEventNotifier extends EventNotifierSupport {

  private final RouteStateRepository repository;
  private final String instanceName;
  private final AppReadiness readiness;

  public RouteStateEventNotifier(CamelContext camelContext,
                                 RouteStateRepository repository,
                                 String instanceName,
                                 AppReadiness readiness) {
    this.repository = repository;
    this.instanceName = instanceName;
    this.readiness = readiness;
    camelContext.getManagementStrategy().addEventNotifier(this);
  }

  @Override
  public void notify(CamelEvent event) {
    if (!readiness.isReady()) {
      return; // ‚õî ignore bootstrap + shutdown
    }

    if (event instanceof RouteStoppedEvent e) {
      repository.upsert(instanceName, e.getRoute().getId(), "STOPPED");
    }
    else if (event instanceof RouteStartedEvent e) {
      repository.upsert(instanceName, e.getRoute().getId(), "STARTED");
    }
  }

  @Override
  public boolean isEnabled(CamelEvent event) {
    return event instanceof RouteStoppedEvent
        || event instanceof RouteStartedEvent;
  }
}


---

5Ô∏è‚É£ RouteStateRepository (Oracle UPSERT par instance)

üîÅ Modifi√©

@Repository
public class RouteStateRepository {

  private final JdbcTemplate jdbc;

  public RouteStateRepository(JdbcTemplate jdbc) {
    this.jdbc = jdbc;
  }

  public void upsert(String instanceName, String routeId, String desiredState) {
    jdbc.update("""
      merge into CAMEL_ROUTE_STATE t
      using (
        select ? as INSTANCE_NAME,
               ? as ROUTE_ID,
               ? as DESIRED_STATE,
               ? as UPDATED_AT
        from dual
      ) s
      on (
        t.INSTANCE_NAME = s.INSTANCE_NAME
        and t.ROUTE_ID = s.ROUTE_ID
      )
      when matched then
        update set
          t.DESIRED_STATE = s.DESIRED_STATE,
          t.UPDATED_AT = s.UPDATED_AT
      when not matched then
        insert (INSTANCE_NAME, ROUTE_ID, DESIRED_STATE, UPDATED_AT)
        values (s.INSTANCE_NAME, s.ROUTE_ID, s.DESIRED_STATE, s.UPDATED_AT)
      """,
      instanceName,
      routeId,
      desiredState,
      Timestamp.from(Instant.now())
    );
  }

  public Map<String, String> loadAllForInstance(String instanceName) {
    return jdbc.query("""
      select ROUTE_ID, DESIRED_STATE
      from CAMEL_ROUTE_STATE
      where INSTANCE_NAME = ?
      """, rs -> {
        Map<String, String> map = new HashMap<>();
        while (rs.next()) {
          map.put(
            rs.getString("ROUTE_ID"),
            rs.getString("DESIRED_STATE")
          );
        }
        return map;
      }, instanceName);
  }
}


---

6Ô∏è‚É£ Suppression de ApplicationRunner ‚ùå

üëâ Cette classe doit dispara√Ætre :

RouteStateStartupApplier


---

7Ô∏è‚É£ Nouveau d√©marrage contr√¥l√© des routes (option 1)

application.properties

camel.springboot.auto-startup=false

Routes

.autoStartup(false)

Nouveau composant de d√©marrage

@Component
public class RouteStartupManager {

  private final CamelContext camelContext;
  private final RouteStateRepository repository;
  private final String instanceName;

  public RouteStartupManager(CamelContext camelContext,
                             RouteStateRepository repository,
                             String instanceName) {
    this.camelContext = camelContext;
    this.repository = repository;
    this.instanceName = instanceName;
  }

  @EventListener(ApplicationReadyEvent.class)
  public void startRoutes() throws Exception {

    camelContext.start(); // aucune route ne d√©marre

    var states = repository.loadAllForInstance(instanceName);

    for (var route : camelContext.getRoutes()) {
      String routeId = route.getId();
      String desired = states.getOrDefault(routeId, "STARTED");

      if ("STOPPED".equalsIgnoreCase(desired)) {
        continue;
      }

      camelContext.getRouteController().startRoute(routeId);
    }
  }
}


---

‚úÖ Ce que tu as maintenant

‚úîÔ∏è √©tat par instance
‚úîÔ∏è persistance uniquement runtime (Hawtio)
‚úîÔ∏è aucune √©criture au boot / shutdown
‚úîÔ∏è Oracle clean (MERGE)
‚úîÔ∏è routes d√©marr√©es uniquement si autoris√©es
‚úîÔ∏è design d√©terministe et maintenable

Si tu veux, au prochain message je peux te proposer :

une colonne UPDATED_BY pr√™te pour la s√©curit√© GCP/Jolokia

ou un health-check bloquant (DB / FS / EMS) avant ApplicationReadyEvent. 
