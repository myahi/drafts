@NonCPS
def parseXmlText(String xmlText) {
  return new XmlSlurper(false, false).parseText(xmlText)
}

@NonCPS
def detectModulesFromPoms(String parentPomText, Map<String, String> modulePomTexts) {
  def parent = parseXmlText(parentPomText)

  def moduleDirs = parent.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
  if (!moduleDirs) return [modules: [], artifactIds: []]

  def artifactIds = moduleDirs.collect { m ->
    def mpomText = modulePomTexts[m]
    if (!mpomText) {
      throw new RuntimeException("pom.xml introuvable pour le module: ${m}")
    }
    def mpom = parseXmlText(mpomText)
    def aid = mpom.artifactId?.text()?.trim()
    if (!aid) {
      throw new RuntimeException("artifactId introuvable dans pom du module: ${m}")
    }
    return aid
  }.unique()

  return [modules: moduleDirs, artifactIds: artifactIds]
}

pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {

          // ===== MAP CENTRALE (EXEMPLE – À ALIGNER AVEC TON EXISTANT) =====
          def MATRIX = [
            "eai-camel-report": [
              dev:     [ mono: ['sdv4eai02']],
              recette: [ mono: ['src4eai05']],
              preprod: [ mono: ['spp4eai02']]
            ],
            "eai-bofi-rgv": [
              dev:     [ mono: ['sdv4eai02'] ],
              recette: [ mono: ['src4eai05'] ],
              preprod: [ mono: ['spp4eai02'] ]
            ]
          ]

          if (!params.APP?.trim()) {
            error("APP requis")
          }
          if (!params.INSTANCE?.trim()) {
            error("INSTANCE requis")
          }

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) {
            error("ENV non supporté pour APP=${params.APP}")
          }

          if (!envMap.containsKey(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisée. Autorisées: ${envMap.keySet()}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) {
            error("Aucune VM configurée pour ${params.APP}/${params.ENV}/${params.INSTANCE}")
          }

          env.TARGET_VMS = targets.join(',')

          echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION}
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
        }
      }
    }

    stage('Checkout application repository') {
      steps {
        checkout scm
      }
    }

    stage('Detect mono / multi-module') {
      steps {
        script {

          if (!fileExists('pom.xml')) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def parentPomText = readFile('pom.xml')
          def tmp = detectModulesFromPoms(parentPomText, [:])
          def moduleDirs = tmp.modules

          if (!moduleDirs || moduleDirs.isEmpty()) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def modulePomTexts = [:]
          moduleDirs.each { m ->
            def p = "${m}/pom.xml"
            if (!fileExists(p)) {
              error("pom.xml introuvable pour le module: ${m}")
            }
            modulePomTexts[m] = readFile(p)
          }

          def res = detectModulesFromPoms(parentPomText, modulePomTexts)
          env.MODULES  = res.artifactIds.join(',')
          env.IS_MULTI = "true"
        }
      }
    }

    stage('Operate application') {
      steps {
        script {

          def hosts = env.TARGET_VMS.split(',')

          if (env.IS_MULTI == "true") {

            def modules
            if (params.MODULE == 'ALL') {
              modules = env.MODULES.split(',')
            } else {
              modules = [ params.MODULE ]
            }

            hosts.each { host ->
              modules.each { mod ->

                def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/config"

                operate(host, binDir)

                if (params.ACTION != 'stop') {
                  healthcheckStable(host, cfgDir)
                }
              }
            }

          } else {

            hosts.each { host ->

              def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
              def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/config"

              operate(host, binDir)

              if (params.ACTION != 'stop') {
                healthcheckStable(host, cfgDir)
              }
            }
          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  sh """
    echo ">>> OPERATE ${params.ACTION} on ${host} (${binDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${params.ACTION}.sh" ]]; then
        "./${params.ACTION}.sh"
      else
        echo "ERROR: ${params.ACTION}.sh introuvable dans ${binDir}"
        exit 127
      fi
    '
  """
}

def healthcheckStable(String host, String configDir) {
  sh """
    echo ">>> HEALTHCHECK STABLE on ${host} (${configDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail

      CONF_DIR="${configDir}"
      PROP_FILE="\${CONF_DIR}/application.properties"

      PORT=""

      if [[ -f "\${PROP_FILE}" ]]; then
        if grep -q "^management.server.port=" "\${PROP_FILE}"; then
          PORT=\$(grep "^management.server.port=" "\${PROP_FILE}" | tail -1 | cut -d= -f2)
        elif grep -q "^server.port=" "\${PROP_FILE}"; then
          PORT=\$(grep "^server.port=" "\${PROP_FILE}" | tail -1 | cut -d= -f2)
        fi
      fi

      [[ -n "\${PORT}" ]] || PORT=8080
      echo "Using port=\${PORT}"

      STABLE_REQUIRED=5
      SLEEP=5
      MAX_LOOPS=24   # 24 * 5s = 120s max
      ok=0
      i=1

      while [ \$i -le \$MAX_LOOPS ]; do
        if curl -fs "http://127.0.0.1:\${PORT}/actuator/health" | grep -q '"status":"UP"'; then
          ok=\$((ok+1))
          echo "UP (\${ok}/\${STABLE_REQUIRED})"
          if [ "\${ok}" -ge "\${STABLE_REQUIRED}" ]; then
            echo "Healthcheck STABLE OK"
            exit 0
          fi
        else
          echo "Not UP -> reset counter"
          ok=0
        fi
        sleep \$SLEEP
        i=\$((i+1))
      done

      echo "ERROR: Healthcheck FAILED to reach STABLE UP"
      exit 1
    '
  """
}
