Parfait. Voici la version compl√®te, finale et non abr√©g√©e, avec toutes les √©tapes et un Jenkinsfile OPS entier, sans raccourci, sans m√©lange avec le job de d√©ploiement, et align√© exactement avec ce que tu as d√©cid√©.


---

üß± ARCHITECTURE FINALE (RAPPEL)

Job 1 ‚Äì DEPLOY
üëâ Ton Jenkinsfile existant (jar, zip, Artifactory, install)
üëâ INCHANG√â

Job 2 ‚Äì OPS
üëâ NOUVEAU job Jenkins
üëâ Start / Stop / Restart uniquement
üëâ Mono / Multi d√©tect√© via le POM
üëâ S√©lection :

application

environnement

instance (couleur)

module (ALL ou un module pr√©cis)




---

1Ô∏è‚É£ PR√â-REQUIS C√îT√â VM

Dans chaque r√©pertoire bin/, les scripts suivants doivent exister et √™tre ex√©cutables :

start.sh
stop.sh
restart.sh

Layout attendu sur les VM

Application mono-module

/serveur_apps/<APP>/<INSTANCE>/bin

Application multi-module

/serveur_apps/<APP>/<INSTANCE>/<MODULE>/bin

Exemples r√©els :

/serveur_apps/eai-camel-report/vert/base/bin
/serveur_apps/eai-camel-report/vert/cashflows/bin
/serveur_apps/eai-bofi-rgv/rouge/bin


---

2Ô∏è‚É£ GUI JENKINS ‚Äì PARAM√àTRES DU JOB OPS

üëâ Les param√®tres APP / ENV / INSTANCE sont les m√™mes que dans ton job deploy
üëâ On ajoute seulement ACTION et MODULE

Param√®tres Jenkins

APP (choice)
Ex : eai-camel-report, eai-bofi-rgv

ENV (choice)
dev | recette | preprod | prod

INSTANCE (choice)
vert | bleu | rouge
(valid√© via ta MAP interne)

ACTION (choice)
start | stop | restart

MODULE (choice)
ALL | base | cashflows | ‚Ä¶
(ignor√© si mono-module)



---

3Ô∏è‚É£ CE QUE TU GARDES TEL QUEL

Dans ce Jenkinsfile OPS, tu r√©utilises exactement la m√™me logique que dans ton job deploy pour :

la MAP APP / ENV / INSTANCE ‚Üí VMs

la validation des entr√©es

la d√©tection mono / multi-module via le pom.xml

les variables calcul√©es :

env.IS_MULTI

env.MODULES

env.TARGET_VMS



üëâ Aucune red√©finition, aucune saisie libre.


---

4Ô∏è‚É£ JENKINSFILE OPS ‚Äì VERSION COMPL√àTE (NON ABR√âG√âE)

üëâ √Ä copier tel quel dans le job OPS.


@NonCPS
def parseXmlText(String xmlText) {
  return new XmlSlurper(false, false).parseText(xmlText)
}

@NonCPS
def detectModulesFromPoms(String parentPomText, Map<String, String> modulePomTexts) {
  def parent = parseXmlText(parentPomText)

  def moduleDirs = parent.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
  if (!moduleDirs) return [modules: [], artifactIds: []]

  def artifactIds = moduleDirs.collect { m ->
    def mpomText = modulePomTexts[m]
    if (!mpomText) {
      throw new RuntimeException("pom.xml introuvable pour le module: ${m}")
    }
    def mpom = parseXmlText(mpomText)
    def aid = mpom.artifactId?.text()?.trim()
    if (!aid) {
      throw new RuntimeException("artifactId introuvable dans pom du module: ${m}")
    }
    return aid
  }.unique()

  return [modules: moduleDirs, artifactIds: artifactIds]
}

pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {

          // ===== MAP CENTRALE (EXEMPLE ‚Äì √Ä ALIGNER AVEC TON EXISTANT) =====
          def MATRIX = [
            "eai-camel-report": [
              dev:     [ vert: ['sdv4eai02'], bleu: ['sdv4eai03'] ],
              recette: [ vert: ['src4eai02'], bleu: ['src4eai03'] ],
              preprod: [ vert: ['spp4eai02'], bleu: ['spp4eai03'] ],
              prod:    [ vert: ['spr4eai02'], bleu: ['spr4eai03'] ]
            ],
            "eai-bofi-rgv": [
              dev:     [ vert: ['sdv4eai10'], bleu: ['sdv4eai11'], rouge: ['sdv4eai12'] ],
              recette: [ vert: ['src4eai10'], bleu: ['src4eai11'], rouge: ['src4eai12'] ],
              preprod: [ vert: ['spp4eai10'], bleu: ['spp4eai11'], rouge: ['spp4eai12'] ],
              prod:    [ vert: ['spr4eai10'], bleu: ['spr4eai11'], rouge: ['spr4eai12'] ]
            ]
          ]

          if (!params.APP?.trim()) {
            error("APP requis")
          }
          if (!params.INSTANCE?.trim()) {
            error("INSTANCE requis")
          }

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) {
            error("ENV non support√© pour APP=${params.APP}")
          }

          if (!envMap.containsKey(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autoris√©e. Autoris√©es: ${envMap.keySet()}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) {
            error("Aucune VM configur√©e pour ${params.APP}/${params.ENV}/${params.INSTANCE}")
          }

          env.TARGET_VMS = targets.join(',')

          echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION}
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
        }
      }
    }

    stage('Checkout application repository') {
      steps {
        checkout scm
      }
    }

    stage('Detect mono / multi-module') {
      steps {
        script {

          if (!fileExists('pom.xml')) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def parentPomText = readFile('pom.xml')
          def tmp = detectModulesFromPoms(parentPomText, [:])
          def moduleDirs = tmp.modules

          if (!moduleDirs || moduleDirs.isEmpty()) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def modulePomTexts = [:]
          moduleDirs.each { m ->
            def p = "${m}/pom.xml"
            if (!fileExists(p)) {
              error("pom.xml introuvable pour le module: ${m}")
            }
            modulePomTexts[m] = readFile(p)
          }

          def res = detectModulesFromPoms(parentPomText, modulePomTexts)
          env.MODULES  = res.artifactIds.join(',')
          env.IS_MULTI = "true"
        }
      }
    }

    stage('Operate application') {
      steps {
        script {

          def hosts = env.TARGET_VMS.split(',')

          if (env.IS_MULTI == "true") {

            def modules
            if (params.MODULE == 'ALL') {
              modules = env.MODULES.split(',')
            } else {
              modules = [ params.MODULE ]
            }

            hosts.each { host ->
              modules.each { mod ->

                def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/config"

                operate(host, binDir)

                if (params.ACTION != 'stop') {
                  healthcheck(host, cfgDir)
                }
              }
            }

          } else {

            hosts.each { host ->

              def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
              def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/config"

              operate(host, binDir)

              if (params.ACTION != 'stop') {
                healthcheck(host, cfgDir)
              }
            }
          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  sh """
    echo ">>> OPERATE ${params.ACTION} on ${host} (${binDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${params.ACTION}.sh" ]]; then
        "./${params.ACTION}.sh"
      else
        echo "ERROR: ${params.ACTION}.sh introuvable dans ${binDir}"
        exit 127
      fi
    '
  """
}

def healthcheck(String host, String configDir) {
  sh """
    echo ">>> HEALTHCHECK on ${host} (${configDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail

      CONF_DIR="${configDir}"
      PROP_FILE="\${CONF_DIR}/application.properties"

      PORT=""

      if [[ -f "\${PROP_FILE}" ]]; then
        if grep -q "^management.server.port=" "\${PROP_FILE}"; then
          PORT=\$(grep "^management.server.port=" "\${PROP_FILE}" | tail -1 | cut -d= -f2)
        elif grep -q "^server.port=" "\${PROP_FILE}"; then
          PORT=\$(grep "^server.port=" "\${PROP_FILE}" | tail -1 | cut -d= -f2)
        fi
      fi

      if [[ -z "\${PORT}" ]]; then
        PORT=8080
      fi

      echo "Using port=\${PORT}"

      ATTEMPTS=20
      SLEEP=3
      i=1

      while [ \$i -le \$ATTEMPTS ]; do
        if curl -fs "http://127.0.0.1:\${PORT}/actuator/health" | grep -q '"status":"UP"'; then
          echo "Healthcheck OK"
          exit 0
        fi
        echo "Waiting for app... (\$i/\$ATTEMPTS)"
        sleep \$SLEEP
        i=\$((i+1))
      done

      echo "ERROR: Healthcheck FAILED on port \${PORT}"
      exit 1
    '
  """
}

---

5Ô∏è‚É£ CE QUE TU OBTIENS (EXEMPLES R√âELS)

Multi-module (eai-camel-report), instance vert, MODULE=ALL

/serveur_apps/eai-camel-report/vert/base/bin/restart.sh
/serveur_apps/eai-camel-report/vert/cashflows/bin/restart.sh

Multi-module, MODULE=cashflows

/serveur_apps/eai-camel-report/vert/cashflows/bin/restart.sh

Mono-module (eai-bofi-rgv)

/serveur_apps/eai-bofi-rgv/rouge/bin/restart.sh


---

6Ô∏è‚É£ R√âCAP FINAL (COURT)

‚úîÔ∏è Jenkins est le bon outil

‚úîÔ∏è S√©paration DEPLOY / OPS

‚úîÔ∏è Mono / multi auto

‚úîÔ∏è Modules ciblables ou ALL

‚úîÔ∏è Z√©ro jar / zip / Artifactory

‚úîÔ∏è Chemins r√©els et absolus


Tu as maintenant une base OPS propre, industrielle et exploitable en prod.
Si tu veux, prochain pas possible :

rolling restart

healthcheck Spring Boot

dry-run

approval prod


Dis-moi üëå
