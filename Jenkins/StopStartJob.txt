@NonCPS
def parseXmlNoNs(String xml) {
  return new XmlSlurper(false, false).parseText(xml)
}

@NonCPS
def extractModuleDirsNoNs(String parentPomText) {
  def pom = parseXmlNoNs(parentPomText)
  def mods = pom.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
  return mods
}

@NonCPS
def artifactIdFromPomNoNs(String pomText) {
  def pom = parseXmlNoNs(pomText)
  def aid = pom.artifactId?.text()?.trim()
  if (!aid) throw new RuntimeException("artifactId introuvable dans pom")
  return aid
}

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  environment {
    ART_CRED = 'eai-marches-0002775-tech-ci-snapshot-user'
    GROUP_PATH = 'fr/labanquepostale/marches/eai'
    JAR_REPO  = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'
    GIT_CRED = 'usr_gitlab_eai'
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {
          try {
            def MATRIX = [
              "eai-camel-report": [
                dev:     [ mono: ['sdv4eai02']],
                recette: [ mono: ['src4eai05']],
                preprod: [ mono: ['spp4eai02']]
              ],
              "eai-bofi-rgv": [
                dev:     [ mono: ['sdv4eai02'] ],
                recette: [ mono: ['src4eai05'] ],
                preprod: [ mono: ['spp4eai02'] ]
              ]
            ]

            if (!params.APP?.trim())      error("APP requis")
            if (!params.INSTANCE?.trim()) error("INSTANCE requis")
            if (!params.ACTION?.trim())   error("ACTION requis")

            def envMap = MATRIX[params.APP]?.get(params.ENV)
            if (!envMap) error("ENV non supporté pour APP=${params.APP}")

            if (!envMap.containsKey(params.INSTANCE)) {
              error("INSTANCE '${params.INSTANCE}' non autorisée. Autorisées: ${envMap.keySet()}")
            }

            def targets = envMap[params.INSTANCE]
            if (!targets || targets.isEmpty()) {
              error("Aucune VM configurée pour ${params.APP}/${params.ENV}/${params.INSTANCE}")
            }
            env.TARGET_VMS = targets.join(',')

            // Normalisation ACTION (stop/start/restart/status)
            env.ACTION_NORM = params.ACTION.toString().trim().toLowerCase()

            echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION} (norm=${env.ACTION_NORM})
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
          } catch (e) {
            echo "Erreur pendant le stage Resolve & validate inputs"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Checkout Git configuration') {
      steps {
        script {
          try {
            def branch = (params.ENV == 'prod') ? 'master' : 'develop'
            def repoUrl = "${env.EAI_REPO_URL}/${params.APP}.git"
            echo "Checkout repo=${repoUrl} branch=${branch}"

            checkout([
              $class: 'GitSCM',
              branches: [[name: branch]],
              userRemoteConfigs: [[
                url: repoUrl,
                credentialsId: env.GIT_CRED
              ]]
            ])
          } catch (e) {
            echo "Erreur pendant le stage Checkout Git configuration"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Modules resolution') {
      steps {
        script {
          try {
            if (!fileExists('pom.xml')) {
              env.MODULES = params.APP
              env.IS_MULTI = "false"
              echo "No pom.xml -> fallback mono: MODULES=${env.MODULES}"
              return
            }

            def parentPomText = readFile('pom.xml')
            def moduleDirs = extractModuleDirsNoNs(parentPomText)

            if (!moduleDirs || moduleDirs.isEmpty()) {
              env.MODULES = params.APP
              env.IS_MULTI = "false"
              echo "Mono-module detected -> MODULES=${env.MODULES}"
              return
            }

            def artifactIds = []
            moduleDirs.each { m ->
              def p = "${m}/pom.xml"
              if (!fileExists(p)) error("pom.xml introuvable pour le module: ${m} (attendu: ${p})")
              artifactIds << artifactIdFromPomNoNs(readFile(p))
            }

            env.MODULES = artifactIds.unique().join(',')
            env.IS_MULTI = "true"
            echo "Multi-module detected -> MODULES=${env.MODULES}"
          } catch (e) {
            echo "Erreur pendant le stage Modules resolution"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Operate application') {
      steps {
        script {
          try {
            def hosts = env.TARGET_VMS.split(',').collect { it.trim() }.findAll { it }
            if (!hosts) error("TARGET_VMS vide")

            if (env.IS_MULTI == "true") {
              // ✅ FIX MIN: si MODULE vide => ALL (au lieu de null)
              def requested = (params.MODULE ?: '').toString().trim()
              if (!requested) requested = 'ALL'

              def modules
              if (requested == 'ALL') {
                modules = env.MODULES.split(',').collect { it.trim() }.findAll { it }
              } else {
                modules = [ requested ]
              }

              if (!modules) error("Aucun module à opérer (env.MODULES vide ?)")

              hosts.each { host ->
                modules.each { mod ->
                  def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                  operate(host, binDir)
                }
              }
            } else {
              hosts.each { host ->
                def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
                operate(host, binDir)
              }
            }
          } catch (e) {
            echo "Erreur pendant le stage Operate application"
            echo e.toString()
            throw e
          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  def action = (env.ACTION_NORM ?: (params.ACTION ?: '')) as String
  action = action.trim().toLowerCase()

  sh """
    echo ">>> OPERATE ${action} on ${host} (${binDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${action}.sh" ]]; then
        "./${action}.sh"
      else
        echo "ERROR: ${action}.sh introuvable dans ${binDir}"
        ls -la
        exit 127
      fi
    '
  """
}





stage('Operate application') {
  steps {
    script {
      try {
        def hosts = env.TARGET_VMS.split(',').collect { it.trim() }.findAll { it }

        if (env.IS_MULTI == "true") {

          // MODULE obligatoire en multi (sinon mod=null => /null/bin)
          if (!params.MODULE?.toString()?.trim()) {
            error("Paramètre MODULE requis en multi-module (valeurs: ALL ou un module de ${env.MODULES})")
          }

          def modules
          if (params.MODULE == 'ALL') {
            modules = env.MODULES.split(',').collect { it.trim() }.findAll { it }
          } else {
            modules = [ params.MODULE.toString().trim() ]
          }

          hosts.each { host ->
            modules.each { mod ->
              def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
              operate(host, binDir)
            }
          }

        } else {
          hosts.each { host ->
            def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
            operate(host, binDir)
          }
        }

      } catch (e) {
        echo "Erreur pendant le stage Operate application"
        echo e.toString()
        throw e
      }
    }
  }
}


@NonCPS
def parseXmlNoNs(String xml) {
  // On ignore les namespaces pour simplifier (pas de p:)
  return new XmlSlurper(false, false).parseText(xml)
}

@NonCPS
def extractModuleDirsNoNs(String parentPomText) {
  def pom = parseXmlNoNs(parentPomText)
  def mods = pom.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
  return mods
}

@NonCPS
def artifactIdFromPomNoNs(String pomText) {
  def pom = parseXmlNoNs(pomText)
  def aid = pom.artifactId?.text()?.trim()
  if (!aid) throw new RuntimeException("artifactId introuvable dans pom")
  return aid
}

pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    ART_CRED = 'eai-marches-0002775-tech-ci-snapshot-user'
    GROUP_PATH = 'fr/labanquepostale/marches/eai'
    JAR_REPO  = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'
    GIT_CRED = 'usr_gitlab_eai'
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }
  
  

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {

          // ===== MAP CENTRALE (EXEMPLE – À ALIGNER AVEC TON EXISTANT) =====
          def MATRIX = [
            "eai-camel-report": [
              dev:     [ mono: ['sdv4eai02']],
              recette: [ mono: ['src4eai05']],
              preprod: [ mono: ['spp4eai02']]
            ],
            "eai-bofi-rgv": [
              dev:     [ mono: ['sdv4eai02'] ],
              recette: [ mono: ['src4eai05'] ],
              preprod: [ mono: ['spp4eai02'] ]
            ]
          ]

          if (!params.APP?.trim()) {
            error("APP requis")
          }
          if (!params.INSTANCE?.trim()) {
            error("INSTANCE requis")
          }

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) {
            error("ENV non supporté pour APP=${params.APP}")
          }

          if (!envMap.containsKey(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisée. Autorisées: ${envMap.keySet()}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) {
            error("Aucune VM configurée pour ${params.APP}/${params.ENV}/${params.INSTANCE}")
          }

          env.TARGET_VMS = targets.join(',')

          echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION}
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
        }
      }
    }

     stage('Checkout Git configuration') {
      steps {
        script {
          try {
            def branch = (params.ENV == 'prod') ? 'master' : 'develop'
            def repoUrl = "${env.EAI_REPO_URL}/${params.APP}.git"
            echo "Checkout repo=${repoUrl} branch=${branch}"

            checkout([
              $class: 'GitSCM',
              branches: [[name: branch]],
              userRemoteConfigs: [[
                url: repoUrl,
                credentialsId: env.GIT_CRED
              ]]
            ])
          } catch (e) {
            echo "Erreur pendant le stage Checkout Git configuration"
            echo e.toString()
            throw e
          }
        }
      }
    }
    stage('Modules resolution') {
      steps {
        script {
          try {
            if (!fileExists('pom.xml')) {
              env.MODULES = params.APP
              env.IS_MULTI = "false"
              echo "No pom.xml -> fallback mono: MODULES=${env.MODULES}"
              return
            }

            def parentPomText = readFile('pom.xml')
            def moduleDirs = extractModuleDirsNoNs(parentPomText)

            if (!moduleDirs || moduleDirs.isEmpty()) {
              env.MODULES = params.APP
              env.IS_MULTI = "false"
              echo "Mono-module detected -> MODULES=${env.MODULES}"
              return
            }

            def artifactIds = []
            moduleDirs.each { m ->
              def p = "${m}/pom.xml"
              if (!fileExists(p)) error("pom.xml introuvable pour le module: ${m} (attendu: ${p})")
              artifactIds << artifactIdFromPomNoNs(readFile(p))
            }

            env.MODULES = artifactIds.unique().join(',')
            env.IS_MULTI = "true"
            echo "Multi-module detected -> MODULES=${env.MODULES}"
          } catch (e) {
            echo "Erreur pendant le stage Modules resolution"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Operate application') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          if (env.IS_MULTI == "true") {
            def modules
            if (params.MODULE == 'ALL') {
              modules = env.MODULES.split(',')
            } else {
              modules = [ params.MODULE ]
            }
            hosts.each { host ->
              modules.each { mod ->
                def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/config"
                operate(host, binDir)
              }
            }
          } else {
            hosts.each { host ->
              def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
              def cfgDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/config"
              operate(host, binDir)
            }
          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  sh """
    echo ">>> OPERATE ${params.ACTION} on ${host} (${binDir})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${params.ACTION}.sh" ]]; then
        "./${params.ACTION}.sh"
      else
        echo "ERROR: ${params.ACTION}.sh introuvable dans ${binDir}"
        exit 127
      fi
    '
  """
}

