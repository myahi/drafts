@NonCPS
def parseXmlNoNs(String xml) {
  // Ignore les namespaces (pas de p:)
  return new XmlSlurper(false, false).parseText(xml)
}

@NonCPS
def extractModuleDirsNoNs(String parentPomText) {
  def pom = parseXmlNoNs(parentPomText)
  return pom.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
}

@NonCPS
def artifactIdFromPomNoNs(String pomText) {
  def pom = parseXmlNoNs(pomText)
  def aid = pom.artifactId?.text()?.trim()
  if (!aid) throw new RuntimeException("artifactId introuvable dans pom")
  return aid
}

def operateOnHost(String host, String binDir, String action, String appInstanceName) {
  sh """
    set -euo pipefail
    echo ">>> OPERATE ${action} on ${host} (bin=${binDir}, appInstance=${appInstanceName})"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${action}.sh" ]]; then
        "./${action}.sh" "${appInstanceName}"
      else
        echo "ERROR: ${action}.sh introuvable dans ${binDir}"
        echo "DEBUG: contenu de ${binDir}:"
        ls -la
        exit 127
      fi
    '
  """
}

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }


  environment {
    ART_CRED   = 'eai-marches-0002775-tech-ci-snapshot-user'
    GROUP_PATH = 'fr/labanquepostale/marches/eai'
    JAR_REPO   = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO  = 'eai-marches-0002775-maven-local-sas'
    GIT_CRED   = 'usr_gitlab_eai'

    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {
          try {
            def MATRIX = [
              "eai-camel-report": [
                dev:     [ mono: ['sdv4eai02'] ],
                recette: [ mono: ['src4eai05'] ],
                preprod: [ mono: ['spp4eai02'] ],
                prod:    [ mono: ['spr4eai02'] ]
              ],
              "eai-bofi-rgv": [
                dev:     [ mono: ['sdv4eai02'] ],
                recette: [ mono: ['src4eai05'] ],
                preprod: [ mono: ['spp4eai02'] ],
                prod:    [ mono: ['spr4eai02'] ]
              ]
            ]

            if (!params.APP?.trim()) error("APP requis")
            if (!params.ENV?.trim()) error("ENV requis")
            if (!params.INSTANCE?.trim()) error("INSTANCE requis")
            if (!params.ACTION?.trim()) error("ACTION requis")

            def envMap = MATRIX[params.APP]?.get(params.ENV)
            if (!envMap) error("ENV non supporté pour APP=${params.APP} (ENV=${params.ENV})")

            if (!envMap.containsKey(params.INSTANCE)) {
              error("INSTANCE '${params.INSTANCE}' non autorisée pour ${params.APP}/${params.ENV}. Autorisées: ${envMap.keySet()}")
            }

            def targets = envMap[params.INSTANCE]
            if (!targets || targets.isEmpty()) error("Aucune VM configurée pour ${params.APP}/${params.ENV}/${params.INSTANCE}")

            env.TARGET_VMS = targets.join(',')

            echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION}
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
          } catch (e) {
            echo "Erreur pendant le stage Resolve & validate inputs"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Checkout Git configuration') {
      steps {
        script {
          try {
            def branch = (params.ENV == 'prod') ? 'master' : 'develop'
            def repoUrl = "${env.EAI_REPO_URL}/${params.APP}.git"
            echo "Checkout repo=${repoUrl} branch=${branch}"

            checkout([
              $class: 'GitSCM',
              branches: [[name: branch]],
              userRemoteConfigs: [[
                url: repoUrl,
                credentialsId: env.GIT_CRED
              ]]
            ])
          } catch (e) {
            echo "Erreur pendant le stage Checkout Git configuration"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Modules resolution') {
      steps {
        script {
          try {
            if (!fileExists('pom.xml')) {
              env.IS_MULTI = "false"
              env.MODULES  = params.APP
              echo "No pom.xml -> mono par défaut: MODULES=${env.MODULES}"
              return
            }

            def parentPomText = readFile('pom.xml')
            def moduleDirs = extractModuleDirsNoNs(parentPomText)

            if (!moduleDirs || moduleDirs.isEmpty()) {
              env.IS_MULTI = "false"
              env.MODULES  = params.APP
              echo "Mono-module detected -> MODULES=${env.MODULES}"
              return
            }

            def artifactIds = []
            moduleDirs.each { m ->
              def p = "${m}/pom.xml"
              if (!fileExists(p)) error("pom.xml introuvable pour le module: ${m} (attendu: ${p})")
              artifactIds << artifactIdFromPomNoNs(readFile(p))
            }

            env.IS_MULTI = "true"
            env.MODULES  = artifactIds.unique().join(',')

            echo "Multi-module detected -> MODULES=${env.MODULES}"
          } catch (e) {
            echo "Erreur pendant le stage Modules resolution"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Operate application') {
      steps {
        script {
          try {
            def hosts = env.TARGET_VMS.split(',').collect { it.trim() }.findAll { it }

            if (env.IS_MULTI == "true") {
              // --- Validation MODULE obligatoire en multi
              def available = env.MODULES.split(',').collect { it.trim() }.findAll { it }
              def requested = (params.MODULE ?: '').trim()

              if (!requested) {
                error("MODULE requis en multi-module (valeurs: ALL ou un module de ${available})")
              }
              def modulesToOperate
              if (requested == 'ALL') {
                modulesToOperate = available
              } else {
                if (!available.contains(requested)) {
                  error("MODULE invalide: '${requested}'. Valides: ${available}")
                }
                modulesToOperate = [requested]
              }

              hosts.each { host ->
                modulesToOperate.each { mod ->
                  def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                  // Instance applicative attendue par tes scripts: <module>-<instance>
                  def appInstanceName = "${mod}-${params.INSTANCE}"
                  operateOnHost(host, binDir, params.ACTION, appInstanceName)
                }
              }

            } else {
              // --- Mono-module
              hosts.each { host ->
                def binDir = "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
                // Instance applicative: <app>-<instance>
                def appInstanceName = "${params.APP}-${params.INSTANCE}"
                operateOnHost(host, binDir, params.ACTION, appInstanceName)
              }
            }

          } catch (e) {
            echo "Erreur pendant le stage Operate application"
            echo e.toString()
            throw e
          }
        }
      }
    }
  }
}
