Parfait. Voici la version finale, claire et propre, avec sÃ©paration totale DEPLOY / OPS, GUI propre, et UN Jenkinsfile OPS dÃ©diÃ©.
ğŸ‘‰ Aucun jar / zip / Artifactory ici.


---

âœ… Ã‰TAPES COMPLÃˆTES

1ï¸âƒ£ Principe (Ã  graver)

Job 1 = DEPLOY â†’ ton Jenkinsfile actuel (inchangÃ©)

Job 2 = OPS â†’ start / stop / restart uniquement (celui-ci)



---

2ï¸âƒ£ PrÃ©-requis cÃ´tÃ© VM

Dans chaque rÃ©pertoire bin/ :

start.sh
stop.sh
restart.sh

Chemins attendus :

Mono-module

/serveur_apps/<APP>/<INSTANCE>/bin

Multi-module

/serveur_apps/<APP>/<INSTANCE>/<MODULE>/bin


---

3ï¸âƒ£ GUI du job Jenkins OPS (PARAMÃˆTRES)

ğŸ‘‰ Tu reprends EXACTEMENT les mÃªmes paramÃ¨tres que ton job deploy, + 1 seul en plus.

ParamÃ¨tres Ã  dÃ©finir dans Jenkins

APP (choice) â†’ mÃªmes valeurs que le job deploy

ENV (choice) â†’ dev / recette / preprod / prod

INSTANCE (choice) â†’ vert / bleu / rouge (pas de texte libre)

ACTION (choice) â†’ start | stop | restart


âœ”ï¸ Les couleurs sont validÃ©es via ta MAP
âœ”ï¸ Aucun champ libre dangereux


---

4ï¸âƒ£ Jenkinsfile OPS (COMPLET ET MINIMAL)

ğŸ‘‰ Ce Jenkinsfile :

lit le POM

dÃ©tecte mono / multi

calcule les chemins

exÃ©cute les scripts en SSH


@NonCPS
def parseXmlText(String xmlText) {
  new XmlSlurper(false, false).parseText(xmlText)
}

@NonCPS
def detectModules(String parentPom, Map modulePoms) {
  def p = parseXmlText(parentPom)
  def modules = p.modules?.module?.collect { it.text().trim() } ?: []
  if (!modules) return []

  modules.collect { m ->
    def mp = parseXmlText(modulePoms[m])
    mp.artifactId.text().trim()
  }
}

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  environment {
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve targets') {
      steps {
        script {
          // === TA MAP (exemple) ===
          def MATRIX = [
            "eai-camel-report": [
              dev: [ vert:['sdv01'], bleu:['sdv02'] ],
              prod:[ vert:['spr01'], bleu:['spr02'] ]
            ],
            "eai-bofi-rgv": [
              dev: [ vert:['sdv10'], bleu:['sdv11'], rouge:['sdv12'] ],
              prod:[ vert:['spr10'], bleu:['spr11'], rouge:['spr12'] ]
            ]
          ]

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) error("ENV non supportÃ©")

          if (!envMap.containsKey(params.INSTANCE)) {
            error("INSTANCE non autorisÃ©e. AutorisÃ©es: ${envMap.keySet()}")
          }

          env.TARGET_VMS = envMap[params.INSTANCE].join(',')
        }
      }
    }

    stage('Checkout repo (read pom)') {
      steps {
        checkout scm
      }
    }

    stage('Detect mono / multi') {
      steps {
        script {
          def parentPom = readFile('pom.xml')
          def xml = parseXmlText(parentPom)
          def moduleDirs = xml.modules?.module?.collect { it.text().trim() }

          if (!moduleDirs) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
          } else {
            def modulePoms = [:]
            moduleDirs.each { modulePoms[it] = readFile("${it}/pom.xml") }
            env.MODULES  = detectModules(parentPom, modulePoms).join(',')
            env.IS_MULTI = "true"
          }
        }
      }
    }

    stage('Operate') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')

          hosts.each { host ->
            if (env.IS_MULTI == "true") {
              env.MODULES.split(',').each { mod ->
                operate(host,
                  "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin")
              }
            } else {
              operate(host,
                "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin")
            }
          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  sh """
    echo ">>> ${host} :: ${binDir} :: ${params.ACTION}"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@${host} '
      set -e
      cd ${binDir}
      ./${params.ACTION}.sh
    '
  """
}


---

5ï¸âƒ£ RÃ©sultat final (exemples)

Multi-module (2 modules, instance vert)

/vert/base/bin/restart.sh
/vert/cashflows/bin/restart.sh

Mono-module (instance rouge)

/rouge/bin/restart.sh


---

6ï¸âƒ£ RÃ©sumÃ© ultra-court

âœ”ï¸ 2 jobs Jenkins

âœ”ï¸ Deploy inchangÃ©

âœ”ï¸ OPS dÃ©diÃ©

âœ”ï¸ Mono / multi auto

âœ”ï¸ Instances sÃ©curisÃ©es

âœ”ï¸ SSH uniquement


Si tu veux ensuite :

rolling restart

dry-run

healthcheck actuator


ğŸ‘‰ on peut les ajouter sans toucher Ã  cette base.
