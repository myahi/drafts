Parfait. Voici la version complÃ¨te, finale et non abrÃ©gÃ©e, avec toutes les Ã©tapes et un Jenkinsfile OPS entier, sans raccourci, sans mÃ©lange avec le job de dÃ©ploiement, et alignÃ© exactement avec ce que tu as dÃ©cidÃ©.


---

ğŸ§± ARCHITECTURE FINALE (RAPPEL)

Job 1 â€“ DEPLOY
ğŸ‘‰ Ton Jenkinsfile existant (jar, zip, Artifactory, install)
ğŸ‘‰ INCHANGÃ‰

Job 2 â€“ OPS
ğŸ‘‰ NOUVEAU job Jenkins
ğŸ‘‰ Start / Stop / Restart uniquement
ğŸ‘‰ Mono / Multi dÃ©tectÃ© via le POM
ğŸ‘‰ SÃ©lection :

application

environnement

instance (couleur)

module (ALL ou un module prÃ©cis)




---

1ï¸âƒ£ PRÃ‰-REQUIS CÃ”TÃ‰ VM

Dans chaque rÃ©pertoire bin/, les scripts suivants doivent exister et Ãªtre exÃ©cutables :

start.sh
stop.sh
restart.sh

Layout attendu sur les VM

Application mono-module

/serveur_apps/<APP>/<INSTANCE>/bin

Application multi-module

/serveur_apps/<APP>/<INSTANCE>/<MODULE>/bin

Exemples rÃ©els :

/serveur_apps/eai-camel-report/vert/base/bin
/serveur_apps/eai-camel-report/vert/cashflows/bin
/serveur_apps/eai-bofi-rgv/rouge/bin


---

2ï¸âƒ£ GUI JENKINS â€“ PARAMÃˆTRES DU JOB OPS

ğŸ‘‰ Les paramÃ¨tres APP / ENV / INSTANCE sont les mÃªmes que dans ton job deploy
ğŸ‘‰ On ajoute seulement ACTION et MODULE

ParamÃ¨tres Jenkins

APP (choice)
Ex : eai-camel-report, eai-bofi-rgv

ENV (choice)
dev | recette | preprod | prod

INSTANCE (choice)
vert | bleu | rouge
(validÃ© via ta MAP interne)

ACTION (choice)
start | stop | restart

MODULE (choice)
ALL | base | cashflows | â€¦
(ignorÃ© si mono-module)



---

3ï¸âƒ£ CE QUE TU GARDES TEL QUEL

Dans ce Jenkinsfile OPS, tu rÃ©utilises exactement la mÃªme logique que dans ton job deploy pour :

la MAP APP / ENV / INSTANCE â†’ VMs

la validation des entrÃ©es

la dÃ©tection mono / multi-module via le pom.xml

les variables calculÃ©es :

env.IS_MULTI

env.MODULES

env.TARGET_VMS



ğŸ‘‰ Aucune redÃ©finition, aucune saisie libre.


---

4ï¸âƒ£ JENKINSFILE OPS â€“ VERSION COMPLÃˆTE (NON ABRÃ‰GÃ‰E)

ğŸ‘‰ Ã€ copier tel quel dans le job OPS.

@NonCPS
def parseXmlText(String xmlText) {
  return new XmlSlurper(false, false).parseText(xmlText)
}

@NonCPS
def detectModulesFromPoms(String parentPomText, Map<String, String> modulePomTexts) {
  def parent = parseXmlText(parentPomText)

  def moduleDirs = parent.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []
  if (!moduleDirs) return [modules: [], artifactIds: []]

  def artifactIds = moduleDirs.collect { m ->
    def mpomText = modulePomTexts[m]
    if (!mpomText) {
      throw new RuntimeException("pom.xml introuvable pour le module: ${m}")
    }
    def mpom = parseXmlText(mpomText)
    def aid = mpom.artifactId?.text()?.trim()
    if (!aid) {
      throw new RuntimeException("artifactId introuvable dans pom du module: ${m}")
    }
    return aid
  }.unique()

  return [modules: moduleDirs, artifactIds: artifactIds]
}

pipeline {
  agent any
  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    BASE_DIR = '/serveur_apps'
  }

  stages {

    stage('Resolve & validate inputs') {
      steps {
        script {

          // === MAP CENTRALE (EXEMPLE â€“ Ã€ ADAPTER Ã€ TON EXISTANT) ===
          def MATRIX = [
            "eai-camel-report": [
              dev:     [ vert: ['sdv4eai02'], bleu: ['sdv4eai03'] ],
              recette: [ vert: ['src4eai02'], bleu: ['src4eai03'] ],
              preprod: [ vert: ['spp4eai02'], bleu: ['spp4eai03'] ],
              prod:    [ vert: ['spr4eai02'], bleu: ['spr4eai03'] ]
            ],
            "eai-bofi-rgv": [
              dev:     [ vert: ['sdv4eai10'], bleu: ['sdv4eai11'], rouge: ['sdv4eai12'] ],
              recette: [ vert: ['src4eai10'], bleu: ['src4eai11'], rouge: ['src4eai12'] ],
              preprod: [ vert: ['spp4eai10'], bleu: ['spp4eai11'], rouge: ['spp4eai12'] ],
              prod:    [ vert: ['spr4eai10'], bleu: ['spr4eai11'], rouge: ['spr4eai12'] ]
            ]
          ]

          if (!params.APP?.trim()) {
            error("APP requis")
          }
          if (!params.INSTANCE?.trim()) {
            error("INSTANCE requis")
          }

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) {
            error("ENV non supportÃ© pour APP=${params.APP}")
          }

          if (!envMap.containsKey(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisÃ©e. AutorisÃ©es: ${envMap.keySet()}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) {
            error("Aucune VM configurÃ©e pour ${params.APP}/${params.ENV}/${params.INSTANCE}")
          }

          env.TARGET_VMS = targets.join(',')

          echo """
========== OPS PLAN ==========
APP       : ${params.APP}
ENV       : ${params.ENV}
INSTANCE  : ${params.INSTANCE}
ACTION    : ${params.ACTION}
MODULE    : ${params.MODULE}
TARGETS   : ${env.TARGET_VMS}
==============================
"""
        }
      }
    }

    stage('Checkout application repository') {
      steps {
        checkout scm
      }
    }

    stage('Detect mono / multi-module') {
      steps {
        script {

          if (!fileExists('pom.xml')) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def parentPomText = readFile('pom.xml')
          def tmp = detectModulesFromPoms(parentPomText, [:])
          def moduleDirs = tmp.modules

          if (!moduleDirs || moduleDirs.isEmpty()) {
            env.IS_MULTI = "false"
            env.MODULES  = ""
            return
          }

          def modulePomTexts = [:]
          moduleDirs.each { m ->
            def p = "${m}/pom.xml"
            if (!fileExists(p)) {
              error("pom.xml introuvable pour le module: ${m}")
            }
            modulePomTexts[m] = readFile(p)
          }

          def res = detectModulesFromPoms(parentPomText, modulePomTexts)
          env.MODULES  = res.artifactIds.join(',')
          env.IS_MULTI = "true"
        }
      }
    }

    stage('Operate application') {
      steps {
        script {

          def hosts = env.TARGET_VMS.split(',')

          if (env.IS_MULTI == "true") {

            def modules
            if (params.MODULE == 'ALL') {
              modules = env.MODULES.split(',')
            } else {
              modules = [ params.MODULE ]
            }

            hosts.each { host ->
              modules.each { mod ->
                operate(
                  host,
                  "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/${mod}/bin"
                )
              }
            }

          } else {

            hosts.each { host ->
              operate(
                host,
                "${env.BASE_DIR}/${params.APP}/${params.INSTANCE}/bin"
              )
            }

          }
        }
      }
    }
  }
}

def operate(String host, String binDir) {
  sh """
    echo ">>> ${host} :: ${binDir} :: ${params.ACTION}"
    ssh ${env.SSH_OPTS} ${env.EAI_SSH_USER}@"${host}" '
      set -euo pipefail
      cd "${binDir}"
      if [[ -x "./${params.ACTION}.sh" ]]; then
        "./${params.ACTION}.sh"
      else
        echo "ERROR: ${params.ACTION}.sh introuvable dans ${binDir}"
        exit 127
      fi
    '
  """
}


---

5ï¸âƒ£ CE QUE TU OBTIENS (EXEMPLES RÃ‰ELS)

Multi-module (eai-camel-report), instance vert, MODULE=ALL

/serveur_apps/eai-camel-report/vert/base/bin/restart.sh
/serveur_apps/eai-camel-report/vert/cashflows/bin/restart.sh

Multi-module, MODULE=cashflows

/serveur_apps/eai-camel-report/vert/cashflows/bin/restart.sh

Mono-module (eai-bofi-rgv)

/serveur_apps/eai-bofi-rgv/rouge/bin/restart.sh


---

6ï¸âƒ£ RÃ‰CAP FINAL (COURT)

âœ”ï¸ Jenkins est le bon outil

âœ”ï¸ SÃ©paration DEPLOY / OPS

âœ”ï¸ Mono / multi auto

âœ”ï¸ Modules ciblables ou ALL

âœ”ï¸ ZÃ©ro jar / zip / Artifactory

âœ”ï¸ Chemins rÃ©els et absolus


Tu as maintenant une base OPS propre, industrielle et exploitable en prod.
Si tu veux, prochain pas possible :

rolling restart

healthcheck Spring Boot

dry-run

approval prod


Dis-moi ğŸ‘Œ
