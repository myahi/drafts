import groovy.json.JsonSlurper
import java.util.Base64
import java.nio.charset.StandardCharsets

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  // IMPORTANT: pas de bloc parameters ici -> tu utilises ceux déjà définis dans l'UI Jenkins

  environment {
    // Artifactory
    ART_URL  = 'https://dlu.pop.sf.intra.laposte.fr/artifactory'
    ART_CRED = 'eai-marches-0002775-tech-ci-snapshot-user'

    GROUP_PATH = 'fr/labanquepostale/marches/eai'

    // Repos Artifactory
    JAR_REPO  = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'

    // Maven artifactId de la conf
    CONF_ARTIFACT = 'eai-camel-rgv-conf'  // <APP>-conf

    // Convention d'installation
    APPS_BASE = '/serveur_apps'

    // SSH
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
  }

  stages {

    stage('Resolve & validate') {
      steps {
        script {
          // Source de vérité: instances autorisées + VMs cibles
          def MATRIX = [
            "eai-camel-rgv": [
              dev:     [ mono: ['sdv4eai02'] ],
              recette: [ mono: ['src4eai02'] ],
              preprod: [ mono: ['spp4eai02'] ],
              prod:    [ mono: ['spr4eai02'] ]
            ]
          ]

          def needsJar  = (params.DEPLOY_MODE in ['BIN_AND_CONF','BIN_ONLY'])
          def needsConf = (params.DEPLOY_MODE in ['BIN_AND_CONF','CONF_ONLY'])

          if (needsJar && !params.JAR_VERSION?.trim())   { error("JAR_VERSION requis pour ${params.DEPLOY_MODE}") }
          if (needsConf && !params.CONF_VERSION?.trim()) { error("CONF_VERSION requis pour ${params.DEPLOY_MODE}") }

          env.NEEDS_JAR  = needsJar.toString()
          env.NEEDS_CONF = needsConf.toString()

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) { error("ENV non supporté: APP=${params.APP} ENV=${params.ENV}") }

          def allowed = envMap.keySet().toList().sort()
          if (!allowed.contains(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisée pour ${params.APP}/${params.ENV}. Autorisées: ${allowed}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) {
            error("Aucune VM configurée pour APP=${params.APP} ENV=${params.ENV} INSTANCE=${params.INSTANCE}")
          }

          env.TARGET_VMS   = targets.join(',')
          env.INSTANCE_DIR = "${params.APP}-${params.INSTANCE}"

          echo """
========== PLAN ==========
APP          : ${params.APP}
ENV          : ${params.ENV}
INSTANCE     : ${params.INSTANCE}
MODE         : ${params.DEPLOY_MODE}
TARGETS      : ${env.TARGET_VMS}
JAR_VERSION  : ${params.JAR_VERSION}
CONF_VERSION : ${params.CONF_VERSION}
========================
"""
        }
      }
    }

    stage('Preflight SSH') {
      steps {
        script {
          try {
            def hosts = env.TARGET_VMS.split(',')
            hosts.each { host ->
              sh """
                set -euo pipefail
                ssh ${env.SSH_OPTS} "${host}" "echo OK: \$(hostname) as \$(whoami)"
              """
            }
          } catch (e) {
            echo "Erreur pendant le stage Preflight SSH"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Prepare remote deploy script') {
      steps {
        script {
          try {
            // Script exécuté SUR LA VM CIBLE
            def scriptText = '''#!/usr/bin/env bash
set -euo pipefail

APP="$1"
ENV_NAME="$2"
INSTANCE="$3"
MODE="$4"
JAR_VERSION_UI="${5:-}"
CONF_VERSION_UI="${6:-}"

APPS_BASE="/serveur_apps"
APP_DIR="${APPS_BASE}/${APP}-${INSTANCE}"
BIN_DIR="${APP_DIR}/bin"
LIB_DIR="${APP_DIR}/lib"
CONFIG_DIR="${APP_DIR}/config"

COLOR=""
if [[ "$INSTANCE" != "mono" ]]; then
  COLOR="$INSTANCE"
fi

mkdir -p "$BIN_DIR" "$LIB_DIR" "$CONFIG_DIR"

run_script() {
  local s="$1"
  if [[ -x "$BIN_DIR/$s" ]]; then
    if [[ -z "$COLOR" ]]; then
      "$BIN_DIR/$s" "$ENV_NAME"
    else
      "$BIN_DIR/$s" "$ENV_NAME" "$COLOR"
    fi
  fi
}

run_script stop.sh

if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "CONF_ONLY" ]]; then
  if [[ ! -f /tmp/conf.zip ]]; then
    echo "ERROR: /tmp/conf.zip absent sur la VM"
    exit 2
  fi

  STAGE_DIR="$(mktemp -d "/tmp/${APP}-conf-stage-XXXXXX")"
  unzip -o "/tmp/conf.zip" -d "$STAGE_DIR"

  rm -rf "$CONFIG_DIR"/*
  mkdir -p "$CONFIG_DIR"

  cp -f "$STAGE_DIR/application.properties" "$CONFIG_DIR/" 2>/dev/null || true
  cp -f "$STAGE_DIR/application-${ENV_NAME}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  if [[ -n "$COLOR" ]]; then
    cp -f "$STAGE_DIR/application-${ENV_NAME}-${COLOR}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  fi

  rm -rf "$STAGE_DIR"
fi

if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "BIN_ONLY" ]]; then
  if [[ ! -f /tmp/app.jar ]]; then
    echo "ERROR: /tmp/app.jar absent sur la VM"
    exit 3
  fi

  mv -f "/tmp/app.jar" "$LIB_DIR/${APP}.jar"
fi

DEPLOYED_AT="$(date --iso-8601=seconds)"
JAR_RESOLVED=""
[[ -f /tmp/jar_resolved_name.txt ]] && JAR_RESOLVED="$(cat /tmp/jar_resolved_name.txt)"

cat > "$APP_DIR/deployed.txt" <<EOF
app=$APP
instance=${APP}-${INSTANCE}
env=$ENV_NAME
color=$COLOR
deployMode=$MODE
jarVersion=$JAR_VERSION_UI
jarResolved=$JAR_RESOLVED
confVersion=$CONF_VERSION_UI
deployedAt=$DEPLOYED_AT
EOF

cat > "$CONFIG_DIR/deploy-info.properties" <<EOF
info.app=$APP
info.instance=${APP}-${INSTANCE}
info.env=$ENV_NAME
info.color=$COLOR
info.deploy.mode=$MODE
info.jar.version=$JAR_VERSION_UI
info.jar.resolved=$JAR_RESOLVED
info.conf.version=$CONF_VERSION_UI
info.deployed.at=$DEPLOYED_AT
EOF

if [[ -x "$BIN_DIR/restart.sh" ]]; then
  run_script restart.sh
else
  run_script start.sh
fi
'''
            writeFile file: 'deploy_remote.sh', text: scriptText
            sh 'chmod +x deploy_remote.sh'
          } catch (e) {
            echo "Erreur pendant le stage Prepare remote deploy script"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Download artifacts (AQL for SNAPSHOT)') {
      steps {
        script {
          try {
            // --- AQL POST robuste (corrige Stream closed) ---
            def aqlPost = { String baseUrl, String user, String pass, String aql ->
              def url = new URL("${baseUrl}/api/search/aql")
              def conn = (HttpURLConnection) url.openConnection()

              conn.setRequestMethod("POST")
              conn.setDoOutput(true)
              conn.setUseCaches(false)
              conn.setConnectTimeout(5000)
              conn.setReadTimeout(15000)

              def auth = Base64.encoder.encodeToString("${user}:${pass}".getBytes(StandardCharsets.UTF_8))
              conn.setRequestProperty("Authorization", "Basic ${auth}")
              conn.setRequestProperty("Content-Type", "text/plain; charset=UTF-8")
              conn.setRequestProperty("Accept", "application/json")

              byte[] payload = aql.getBytes(StandardCharsets.UTF_8)
              conn.setFixedLengthStreamingMode(payload.length)

              conn.getOutputStream().withCloseable { os ->
                os.write(payload)
                os.flush()
              }

              int rc = conn.getResponseCode()
              def stream = (rc >= 200 && rc < 300) ? conn.getInputStream() : conn.getErrorStream()
              def body = stream ? stream.getText("UTF-8") : ""

              if (rc < 200 || rc >= 300) {
                error("Artifactory AQL HTTP ${rc}: ${body?.take(500) ?: ''}")
              }
              return new JsonSlurper().parseText(body)
            }

            def resolveLatestSnapshotPath = { String baseUrl, String user, String pass, String repo, String groupPath, String artifactId, String version, String ext ->
              def baseVer = version.replaceAll(/-SNAPSHOT$/, "")
              def aql = """
items.find({
  "repo": "${repo}",
  "path": {"${'$'}match":"${groupPath}/${artifactId}/${version}"},
  "name": {"${'$'}match":"${artifactId}-${baseVer}-*.${ext}"}
}).include("repo","path","name","created").sort({"${'$'}desc":["created"]}).limit(1)
"""
              def json = aqlPost(baseUrl, user, pass, aql)
              def r = (json?.results ?: []).find { it?.path && it?.name }
              if (!r) return null
              return "${r.path}/${r.name}"
            }

            withCredentials([usernamePassword(credentialsId: env.ART_CRED, usernameVariable: 'ART_USER', passwordVariable: 'ART_PASS')]) {
              sh 'mkdir -p artifacts && rm -f artifacts/* || true'

              if (env.NEEDS_CONF == "true") {
                String confUrl
                String confResolvedName

                if (params.CONF_VERSION?.endsWith("-SNAPSHOT")) {
                  def confPath = resolveLatestSnapshotPath(env.ART_URL, ART_USER, ART_PASS, env.CONF_REPO, env.GROUP_PATH, env.CONF_ARTIFACT, params.CONF_VERSION, "zip")
                  if (!confPath) error("Aucun conf zip SNAPSHOT trouvé pour ${env.CONF_ARTIFACT} VERSION=${params.CONF_VERSION}")
                  confResolvedName = confPath.tokenize('/').last()
                  confUrl = "${env.ART_URL}/${env.CONF_REPO}/${confPath}"
                } else {
                  confResolvedName = "${env.CONF_ARTIFACT}-${params.CONF_VERSION}.zip"
                  confUrl = "${env.ART_URL}/${env.CONF_REPO}/${env.GROUP_PATH}/${env.CONF_ARTIFACT}/${params.CONF_VERSION}/${confResolvedName}"
                }

                writeFile file: 'artifacts/conf_resolved_name.txt', text: confResolvedName + "\n"

                sh """
                  set -euo pipefail
                  echo "Downloading conf: ${confUrl}"
                  curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/conf.zip" "${confUrl}"
                """
              }

              if (env.NEEDS_JAR == "true") {
                String jarUrl
                String jarResolvedName

                if (params.JAR_VERSION?.endsWith("-SNAPSHOT")) {
                  def jarPath = resolveLatestSnapshotPath(env.ART_URL, ART_USER, ART_PASS, env.JAR_REPO, env.GROUP_PATH, params.APP, params.JAR_VERSION, "jar")
                  if (!jarPath) error("Aucun jar SNAPSHOT trouvé pour ${params.APP} VERSION=${params.JAR_VERSION}")
                  jarResolvedName = jarPath.tokenize('/').last()
                  jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${jarPath}"
                } else {
                  jarResolvedName = "${params.APP}-${params.JAR_VERSION}.jar"
                  jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${env.GROUP_PATH}/${params.APP}/${params.JAR_VERSION}/${jarResolvedName}"
                }

                writeFile file: 'artifacts/jar_resolved_name.txt', text: jarResolvedName + "\n"

                sh """
                  set -euo pipefail
                  echo "Downloading jar: ${jarUrl}"
                  curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/app.jar" "${jarUrl}"
                """
              }

              sh 'ls -lh artifacts || true'
            }
          } catch (e) {
            echo "Erreur pendant le stage: Download artifacts (AQL for SNAPSHOT)"
            echo e.toString()
            throw e
          }
        }
      }
    }

    stage('Copy to targets (/tmp)') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              echo "=== Copy to ${host} ==="
              scp ${env.SSH_OPTS} deploy_remote.sh "${host}:/tmp/deploy_remote.sh"
              ${env.NEEDS_JAR == "true" ? "scp ${env.SSH_OPTS} artifacts/app.jar \"${host}:/tmp/app.jar\"" : "true"}
              ${env.NEEDS_CONF == "true" ? "scp ${env.SSH_OPTS} artifacts/conf.zip \"${host}:/tmp/conf.zip\"" : "true"}
              ${fileExists('artifacts/jar_resolved_name.txt') ? "scp ${env.SSH_OPTS} artifacts/jar_resolved_name.txt \"${host}:/tmp/jar_resolved_name.txt\"" : "true"}
            """
          }
        }
      }
    }

    stage('Deploy on targets') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              echo "=== Deploy on ${host} ==="
              ssh ${env.SSH_OPTS} "${host}" "bash /tmp/deploy_remote.sh \
                '${params.APP}' \
                '${params.ENV}' \
                '${params.INSTANCE}' \
                '${params.DEPLOY_MODE}' \
                '${params.JAR_VERSION ?: ''}' \
                '${params.CONF_VERSION ?: ''}'"
            """
          }
        }
      }
    }
  }
}
```0




import groovy.json.JsonSlurper
import java.util.Base64

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }


  environment {
    // Artifactory
    ART_URL  = 'https://dlu.pop.sf.intra.laposte.fr/artifactory'
    ART_CRED = 'eai-marches-0002775-tech-ci-snapshot-user'

    GROUP_PATH = 'fr/labanquepostale/marches/eai'

    // Repos Artifactory
    JAR_REPO  = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'

    // Maven artifactIds
    CONF_ARTIFACT = 'eai-camel-rgv-conf'  // <APP>-conf

    // Convention d'installation
    APPS_BASE = '/serveur_apps'

    // SSH 
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
  }

  stages {

    stage('Resolve & validate') {
  steps {
    script {
      // Source de vérité: instances autorisées + VMs cibles
      def MATRIX = [
            "eai-camel-rgv": [
              dev: [
                mono:  ['sdv4eai02']
              ],
              recette: [
                mono:  ['src4eai02']
              ],
              preprod: [
                mono:  ['spp4eai02']
              ],
              prod: [
                mono:  ['spr4eai02']
              ]
            ]
          ]

      def needsJar  = (params.DEPLOY_MODE in ['BIN_AND_CONF','BIN_ONLY'])
      def needsConf = (params.DEPLOY_MODE in ['BIN_AND_CONF','CONF_ONLY'])

      if (needsJar && !params.JAR_VERSION?.trim())  { error("JAR_VERSION requis pour ${params.DEPLOY_MODE}") }
      if (needsConf && !params.CONF_VERSION?.trim()){ error("CONF_VERSION requis pour ${params.DEPLOY_MODE}") }

      env.NEEDS_JAR  = needsJar.toString()
      env.NEEDS_CONF = needsConf.toString()

      def envMap = MATRIX[params.APP]?.get(params.ENV)
      if (!envMap) { error("ENV non supporté: APP=${params.APP} ENV=${params.ENV}") }

      def allowed = envMap.keySet().toList().sort()
      if (!allowed.contains(params.INSTANCE)) {
        error("INSTANCE '${params.INSTANCE}' non autorisée pour ${params.APP}/${params.ENV}. Autorisées: ${allowed}")
      }

      def targets = envMap[params.INSTANCE]
      if (!targets || targets.isEmpty()) {
        error("Aucune VM configurée pour APP=${params.APP} ENV=${params.ENV} INSTANCE=${params.INSTANCE}")
      }

      env.TARGET_VMS   = targets.join(',')
      env.INSTANCE_DIR = "${params.APP}-${params.INSTANCE}"

      echo """
========== PLAN ==========
APP          : ${params.APP}
ENV          : ${params.ENV}
INSTANCE     : ${params.INSTANCE}
MODE         : ${params.DEPLOY_MODE}
TARGETS      : ${env.TARGET_VMS}
JAR_VERSION  : ${params.JAR_VERSION}
CONF_VERSION : ${params.CONF_VERSION}
========================
"""
    }
  }
}


stage('Preflight SSH') {
      steps {
        script {
		 try {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              ssh ${env.SSH_OPTS} "${host}" "echo OK: \$(hostname) as \$(whoami)"
            """
          }
        } catch (e) {
			echo "Erreur pendant le stage Preflight SSH"
			echo e.toString()
			throw e 
			}
		}
      }
    }

    stage('Prepare remote deploy script') {
      steps {
        script {
		try {
		
          // Script exécuté SUR LA VM CIBLE (pas de Groovy/bordel de $ à échapper dans Jenkinsfile)
          // Il suppose que Jenkins a déjà copié /tmp/app.jar et/ou /tmp/conf.zip selon DEPLOY_MODE
          def scriptText = '''#!/usr/bin/env bash
set -euo pipefail

APP="$1"
ENV_NAME="$2"
INSTANCE="$3"
MODE="$4"
JAR_VERSION_UI="${5:-}"
CONF_VERSION_UI="${6:-}"

APPS_BASE="/serveur_apps"
APP_DIR="${APPS_BASE}/${APP}-${INSTANCE}"
BIN_DIR="${APP_DIR}/bin"
LIB_DIR="${APP_DIR}/lib"
CONFIG_DIR="${APP_DIR}/config"

COLOR=""
if [[ "$INSTANCE" != "mono" ]]; then
  COLOR="$INSTANCE"
fi

mkdir -p "$BIN_DIR" "$LIB_DIR" "$CONFIG_DIR"

run_script() {
  local s="$1"
  if [[ -x "$BIN_DIR/$s" ]]; then
    if [[ -z "$COLOR" ]]; then
      "$BIN_DIR/$s" "$ENV_NAME"
    else
      "$BIN_DIR/$s" "$ENV_NAME" "$COLOR"
    fi
  fi
}

# Stop before overwrite
run_script stop.sh

# ----- CONF install (unzip -> prune) -----
if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "CONF_ONLY" ]]; then
  if [[ ! -f /tmp/conf.zip ]]; then
    echo "ERROR: /tmp/conf.zip absent sur la VM"
    exit 2
  fi

  STAGE_DIR="$(mktemp -d "/tmp/${APP}-conf-stage-XXXXXX")"
  unzip -o "/tmp/conf.zip" -d "$STAGE_DIR"

  rm -rf "$CONFIG_DIR"/*
  mkdir -p "$CONFIG_DIR"

  # garder uniquement:
  # - application.properties
  # - application-<env>.properties
  # - application-<env>-<color>.properties si color
  cp -f "$STAGE_DIR/application.properties" "$CONFIG_DIR/" 2>/dev/null || true
  cp -f "$STAGE_DIR/application-${ENV_NAME}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  if [[ -n "$COLOR" ]]; then
    cp -f "$STAGE_DIR/application-${ENV_NAME}-${COLOR}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  fi

  rm -rf "$STAGE_DIR"
fi

# ----- JAR install (overwrite) -----
if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "BIN_ONLY" ]]; then
  if [[ ! -f /tmp/app.jar ]]; then
    echo "ERROR: /tmp/app.jar absent sur la VM"
    exit 3
  fi

  # overwrite (no local versioning)
  mv -f "/tmp/app.jar" "$LIB_DIR/${APP}.jar"
fi

# ----- Deploy info (Hawtio/JMX via Actuator info.*) -----
DEPLOYED_AT="$(date --iso-8601=seconds)"
JAR_RESOLVED=""
[[ -f /tmp/jar_resolved_name.txt ]] && JAR_RESOLVED="$(cat /tmp/jar_resolved_name.txt)"

cat > "$APP_DIR/deployed.txt" <<EOF
app=$APP
instance=${APP}-${INSTANCE}
env=$ENV_NAME
color=$COLOR
deployMode=$MODE
jarVersion=$JAR_VERSION_UI
jarResolved=$JAR_RESOLVED
confVersion=$CONF_VERSION_UI
deployedAt=$DEPLOYED_AT
EOF

cat > "$CONFIG_DIR/deploy-info.properties" <<EOF
info.app=$APP
info.instance=${APP}-${INSTANCE}
info.env=$ENV_NAME
info.color=$COLOR
info.deploy.mode=$MODE
info.jar.version=$JAR_VERSION_UI
info.jar.resolved=$JAR_RESOLVED
info.conf.version=$CONF_VERSION_UI
info.deployed.at=$DEPLOYED_AT
EOF

# Restart / Start
if [[ -x "$BIN_DIR/restart.sh" ]]; then
  run_script restart.sh
else
  run_script start.sh
fi
'''
          writeFile file: 'deploy_remote.sh', text: scriptText
          sh 'chmod +x deploy_remote.sh'
        }
		catch (e) {
			echo "Erreur pendant le stage Prepare remote deploy script"
			echo e.toString()
			throw e 
			}
		}
      }
    }

    stage('Download artifacts (AQL for SNAPSHOT)') {
      steps {
        script {
		try{
          def aqlPost = { String baseUrl, String user, String pass, String aql ->
            def url = new URL("${baseUrl}/api/search/aql")
            def conn = (HttpURLConnection) url.openConnection()
            conn.setRequestMethod("POST")
            conn.setDoOutput(true)

            def auth = Base64.encoder.encodeToString("${user}:${pass}".getBytes("UTF-8"))
            conn.setRequestProperty("Authorization", "Basic ${auth}")
            conn.setRequestProperty("Content-Type", "text/plain; charset=UTF-8")

            conn.outputStream.withWriter("UTF-8") { it << aql }

            int rc = conn.responseCode
            def stream = (rc >= 200 && rc < 300) ? conn.inputStream : conn.errorStream
            def body = stream ? stream.getText("UTF-8") : ""
            if (rc < 200 || rc >= 300) error("Artifactory AQL HTTP ${rc}: ${body?.take(300) ?: ''}")
            return new JsonSlurper().parseText(body)
          }

          def resolveLatestSnapshotPath = { String baseUrl, String user, String pass, String repo, String groupPath, String artifactId, String version, String ext ->
            def baseVer = version.replaceAll(/-SNAPSHOT$/, "")
            def aql = """
items.find({
  "repo": "${repo}",
  "path": {"${'$'}match":"${groupPath}/${artifactId}/${version}"},
  "name": {"${'$'}match":"${artifactId}-${baseVer}-*.${ext}"}
}).include("repo","path","name","created").sort({"${'$'}desc":["created"]}).limit(1)
"""
            def json = aqlPost(baseUrl, user, pass, aql)
            def r = (json?.results ?: []).find { it?.path && it?.name }
            if (!r) return null
            return "${r.path}/${r.name}"
          }

          withCredentials([usernamePassword(credentialsId: env.ART_CRED, usernameVariable: 'ART_USER', passwordVariable: 'ART_PASS')]) {
            sh 'mkdir -p artifacts && rm -f artifacts/* || true'

            // ----- CONF ZIP -----
            if (env.NEEDS_CONF == "true") {
              String confUrl
              String confResolvedName

              if (params.CONF_VERSION?.endsWith("-SNAPSHOT")) {
                def confPath = resolveLatestSnapshotPath(env.ART_URL, ART_USER, ART_PASS, env.CONF_REPO, env.GROUP_PATH, env.CONF_ARTIFACT, params.CONF_VERSION, "zip")
                if (!confPath) error("Aucun conf zip SNAPSHOT trouvé pour ${env.CONF_ARTIFACT} VERSION=${params.CONF_VERSION}")
                confResolvedName = confPath.tokenize('/').last()
                confUrl = "${env.ART_URL}/${env.CONF_REPO}/${confPath}"
              } else {
                confResolvedName = "${env.CONF_ARTIFACT}-${params.CONF_VERSION}.zip"
                confUrl = "${env.ART_URL}/${env.CONF_REPO}/${env.GROUP_PATH}/${env.CONF_ARTIFACT}/${params.CONF_VERSION}/${confResolvedName}"
              }

              writeFile file: 'artifacts/conf_resolved_name.txt', text: confResolvedName + "\n"

              sh """
                set -euo pipefail
                echo "Downloading conf: ${confUrl}"
                curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/conf.zip" "${confUrl}"
              """
            }

            // ----- JAR -----
            if (env.NEEDS_JAR == "true") {
              String jarUrl
              String jarResolvedName

              if (params.JAR_VERSION?.endsWith("-SNAPSHOT")) {
                def jarPath = resolveLatestSnapshotPath(env.ART_URL, ART_USER, ART_PASS, env.JAR_REPO, env.GROUP_PATH, params.APP, params.JAR_VERSION, "jar")
                if (!jarPath) error("Aucun jar SNAPSHOT trouvé pour ${params.APP} VERSION=${params.JAR_VERSION}")
                jarResolvedName = jarPath.tokenize('/').last()
                jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${jarPath}"
              } else {
                jarResolvedName = "${params.APP}-${params.JAR_VERSION}.jar"
                jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${env.GROUP_PATH}/${params.APP}/${params.JAR_VERSION}/${jarResolvedName}"
              }

              writeFile file: 'artifacts/jar_resolved_name.txt', text: jarResolvedName + "\n"

              sh """
                set -euo pipefail
                echo "Downloading jar: ${jarUrl}"
                curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/app.jar" "${jarUrl}"
              """
            }

            sh 'ls -lh artifacts || true'
          }
		}
		catch (e) {
			echo "Erreur pendant le stage: Download artifacts (AQL for SNAPSHOT)"
			echo e.toString()
			throw e 
			}
		}
      }
	  }

    stage('Copy to targets (/tmp)') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')

          hosts.each { host ->
            // On copie toujours le script + les fichiers présents selon le mode
            def files = ['deploy_remote.sh']
            if (env.NEEDS_JAR == "true")  files << 'artifacts/app.jar'
            if (env.NEEDS_CONF == "true") files << 'artifacts/conf.zip'
            // Pour info deploy-info: on copie le nom résolu (snapshot timestampé)
            if (fileExists('artifacts/jar_resolved_name.txt'))  files << 'artifacts/jar_resolved_name.txt'

            // scp vers /tmp avec des noms stables côté VM
            // - app.jar
            // - conf.zip
            // - jar_resolved_name.txt
            // - deploy_remote.sh
            sh """
              set -euo pipefail
              echo "=== Copy to ${host} ==="
              scp ${env.SSH_OPTS} deploy_remote.sh "${host}:/tmp/deploy_remote.sh"
              ${env.NEEDS_JAR == "true" ? "scp ${env.SSH_OPTS} artifacts/app.jar \"${host}:/tmp/app.jar\"" : "true"}
              ${env.NEEDS_CONF == "true" ? "scp ${env.SSH_OPTS} artifacts/conf.zip \"${host}:/tmp/conf.zip\"" : "true"}
              ${fileExists('artifacts/jar_resolved_name.txt') ? "scp ${env.SSH_OPTS} artifacts/jar_resolved_name.txt \"${host}:/tmp/jar_resolved_name.txt\"" : "true"}
            """
          }
        }
      }
    }

    stage('Deploy on targets') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              echo "=== Deploy on ${host} ==="
              ssh ${env.SSH_OPTS} "${host}" "bash /tmp/deploy_remote.sh \
                '${params.APP}' \
                '${params.ENV}' \
                '${params.INSTANCE}' \
                '${params.DEPLOY_MODE}' \
                '${params.JAR_VERSION ?: ''}' \
                '${params.CONF_VERSION ?: ''}'"
            """
          }
        }
      }
    }
  }
} 
