scp ${env.SSH_OPTS} artifacts/* "${'$'}(whoami)@${host}:/tmp/"


scp ${env.SSH_OPTS} artifacts/* "$(whoami)@${host}:/tmp/"

sh """
  set -euo pipefail
  ssh ${env.SSH_OPTS} "${'$'}(whoami)@${host}" "echo OK: ${'$'}(hostname) as ${'$'}(whoami)"
"""

sh """
              set -euo pipefail
              ssh ${env.SSH_OPTS} "$(whoami)@${host}" "echo OK: \$(hostname) as \$(whoami)"
            """

illegal string body character after dollar sign;
   solution: either escape a literal dollar sign "\$5" or bracket the value expression "${5}"

import groovy.json.JsonSlurper
import java.util.Base64

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  parameters {
    choice(name: 'APP', choices: ['eai-camel-rgv'], description: 'Application')
    choice(name: 'ENV', choices: ['dev','recette','preprod','prod'], description: 'Environnement')

    // mono = sans couleur. Si multi-instance, tu supprimes mono côté MATRIX et tu déploies blue/green.
    choice(name: 'INSTANCE', choices: ['mono','blue','green'], description: 'Instance (mono ou couleur)')

    choice(name: 'DEPLOY_MODE', choices: ['BIN_AND_CONF', 'CONF_ONLY', 'BIN_ONLY'], description: 'Quoi déployer ?')

    string(name: 'JAR_VERSION',  defaultValue: '', description: 'Version jar (Artifactory) - requis si BIN_* (ex: 1.0.0-SNAPSHOT ou 1.0.0)')
    string(name: 'CONF_VERSION', defaultValue: '', description: 'Version conf zip (Artifactory) - requis si *_CONF (ex: 1.0.0-SNAPSHOT ou 1.0.0)')
  }

  environment {
    // Artifactory
    ART_URL  = 'https://dlu.pop.sf.intra.laposte.fr/artifactory'
    ART_CRED = 'artifactory-creds'

    GROUP_PATH = 'fr/labanquepostale/marches/eai'

    // Jar repo
    JAR_REPO = 'eai-marches-0002775-maven-local-sas'

    // Conf zip (artefact Maven zip)
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'
    CONF_ARTIFACT = 'eai-camel-rgv-conf'

    // Convention d'installation
    APPS_BASE = '/serveur_apps'

    // SSH options (ton standard)
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
  }

  stages {

    stage('Resolve & validate') {
      steps {
        script {
          /*
            MATRIX = source de vérité
            - Les clés sous ENV définissent les instances autorisées (mono OU couleurs)
            - Les valeurs sont les VMs cibles
          */
          def MATRIX = [
            "eai-camel-rgv": [
              dev: [
                mono:  ['dev-vm1']          // adapte
              ],
              recette: [
                blue:  ['rec-vm1'],         // adapte
                green: ['rec-vm1']          // adapte
              ],
              preprod: [
                mono:  ['pp-vm1']           // adapte
              ],
              prod: [
                mono:  ['prod-vm1']         // adapte
              ]
            ]
          ]

          def needsJar  = (params.DEPLOY_MODE in ['BIN_AND_CONF','BIN_ONLY'])
          def needsConf = (params.DEPLOY_MODE in ['BIN_AND_CONF','CONF_ONLY'])

          if (needsJar && !params.JAR_VERSION?.trim())   error("JAR_VERSION requis pour ${params.DEPLOY_MODE}")
          if (needsConf && !params.CONF_VERSION?.trim()) error("CONF_VERSION requis pour ${params.DEPLOY_MODE}")

          env.NEEDS_JAR  = needsJar.toString()
          env.NEEDS_CONF = needsConf.toString()

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) error("ENV non supporté: APP=${params.APP} ENV=${params.ENV}")

          def allowed = envMap.keySet().toList().sort()
          if (!allowed.contains(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisée pour ${params.APP}/${params.ENV}. Autorisées: ${allowed}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) error("Aucune VM configurée pour APP=${params.APP} ENV=${params.ENV} INSTANCE=${params.INSTANCE}")

          env.TARGET_VMS = targets.join(',')
          env.INSTANCE_DIR = "${params.APP}-${params.INSTANCE}"

          echo """
========== PLAN DE DEPLOIEMENT ==========
APP          : ${params.APP}
ENV          : ${params.ENV}
INSTANCE     : ${params.INSTANCE}
INSTANCE_DIR : ${env.INSTANCE_DIR}
TARGETS      : ${env.TARGET_VMS}
MODE         : ${params.DEPLOY_MODE}
JAR_VERSION  : ${params.JAR_VERSION}
CONF_VERSION : ${params.CONF_VERSION}
========================================
"""
        }
      }
    }

    stage('Preflight SSH') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              ssh ${env.SSH_OPTS} "$(whoami)@${host}" "echo OK: \$(hostname) as \$(whoami)"
            """
          }
        }
      }
    }

    stage('Download artifacts') {
      steps {
        script {
          def aqlPost = { String baseUrl, String user, String pass, String aql ->
            def url = new URL("${baseUrl}/api/search/aql")
            def conn = (HttpURLConnection) url.openConnection()
            conn.setRequestMethod("POST")
            conn.setDoOutput(true)

            def auth = Base64.encoder.encodeToString("${user}:${pass}".getBytes("UTF-8"))
            conn.setRequestProperty("Authorization", "Basic ${auth}")
            conn.setRequestProperty("Content-Type", "text/plain; charset=UTF-8")

            conn.outputStream.withWriter("UTF-8") { it << aql }

            int rc = conn.responseCode
            def stream = (rc >= 200 && rc < 300) ? conn.inputStream : conn.errorStream
            def body = stream ? stream.getText("UTF-8") : ""
            if (rc < 200 || rc >= 300) error("Artifactory AQL HTTP ${rc}: ${body?.take(300) ?: ''}")

            return new JsonSlurper().parseText(body)
          }

          def resolveLatestSnapshotJarPath = { String baseUrl, String user, String pass, String repo, String groupPath, String app, String jarVersion ->
            def baseVer = jarVersion.replaceAll(/-SNAPSHOT$/, "")
            def aql = """
items.find({
  "repo": "${repo}",
  "path": {"${'$'}match":"${groupPath}/${app}/${jarVersion}"},
  "name": {"${'$'}match":"${app}-${baseVer}-*.jar"}
}).include("repo","path","name","created").sort({"${'$'}desc":["created"]}).limit(1)
"""
            def json = aqlPost(baseUrl, user, pass, aql)
            def r = (json?.results ?: []).find { it?.path && it?.name }
            if (!r) return null
            return "${r.path}/${r.name}"
          }

          withCredentials([usernamePassword(credentialsId: env.ART_CRED, usernameVariable: 'ART_USER', passwordVariable: 'ART_PASS')]) {
            sh 'mkdir -p artifacts && rm -f artifacts/* || true'

            // CONF ZIP
            if (env.NEEDS_CONF == "true") {
              def confZip = "${env.CONF_ARTIFACT}-${params.CONF_VERSION}.zip"
              def confUrl = "${env.ART_URL}/${env.CONF_REPO}/${env.GROUP_PATH}/${env.CONF_ARTIFACT}/${params.CONF_VERSION}/${confZip}"
              sh """
                set -euo pipefail
                echo "Downloading conf: ${confUrl}"
                curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/${confZip}" "${confUrl}"
              """
            }

            // JAR
            if (env.NEEDS_JAR == "true") {
              String jarResolvedName
              String jarUrl

              if (params.JAR_VERSION?.endsWith("-SNAPSHOT")) {
                def jarPath = resolveLatestSnapshotJarPath(env.ART_URL, ART_USER, ART_PASS, env.JAR_REPO, env.GROUP_PATH, params.APP, params.JAR_VERSION)
                if (!jarPath) error("Aucun jar SNAPSHOT trouvé pour APP=${params.APP} VERSION=${params.JAR_VERSION}")

                jarResolvedName = jarPath.tokenize('/').last()
                jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${jarPath}"
              } else {
                jarResolvedName = "${params.APP}-${params.JAR_VERSION}.jar"
                jarUrl = "${env.ART_URL}/${env.JAR_REPO}/${env.GROUP_PATH}/${params.APP}/${params.JAR_VERSION}/${jarResolvedName}"
              }

              writeFile file: 'artifacts/jar_resolved_name.txt', text: jarResolvedName + "\n"

              sh """
                set -euo pipefail
                echo "Downloading jar: ${jarUrl}"
                curl -f -u "${ART_USER}:${ART_PASS}" -o "artifacts/${params.APP}.jar" "${jarUrl}"
              """
            }

            sh 'ls -lh artifacts || true'
          }
        }
      }
    }

    stage('Deploy to targets') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          def appInstanceDir = "${env.APPS_BASE}/${env.INSTANCE_DIR}"
          def binDir = "${appInstanceDir}/bin"
          def libDir = "${appInstanceDir}/lib"
          def configDir = "${appInstanceDir}/config"

          hosts.each { host ->
            sh """
              set -euo pipefail
              echo "=== Deploy on ${host} ==="

              # push artifacts to /tmp (only what exists)
              if ls artifacts/* >/dev/null 2>&1; then
                scp ${env.SSH_OPTS} artifacts/* "$(whoami)@${host}:/tmp/"
              fi

              ssh ${env.SSH_OPTS} "$(whoami)@${host}" 'bash -lc "
                set -euo pipefail

                APP=\\"${params.APP}\\"
                ENV=\\"${params.ENV}\\"
                INSTANCE=\\"${params.INSTANCE}\\"
                MODE=\\"${params.DEPLOY_MODE}\\"

                APP_DIR=\\"${appInstanceDir}\\"
                BIN_DIR=\\"${binDir}\\"
                LIB_DIR=\\"${libDir}\\"
                CONFIG_DIR=\\"${configDir}\\"

                mkdir -p \\"$APP_DIR\\" \\"$BIN_DIR\\" \\"$LIB_DIR\\" \\"$CONFIG_DIR\\"

                # color = instance sauf si mono
                COLOR=\\"\\"
                if [ \\"$INSTANCE\\" != \\"mono\\" ]; then
                  COLOR=\\"$INSTANCE\\"
                fi

                run_script() {
                  local s=\\"$1\\"
                  if [ -x \\"$BIN_DIR/$s\\" ]; then
                    if [ -z \\"$COLOR\\" ]; then
                      \\"$BIN_DIR/$s\\" \\"$ENV\\"
                    else
                      \\"$BIN_DIR/$s\\" \\"$ENV\\" \\"$COLOR\\"
                    fi
                  fi
                }

                run_script stop.sh

                # ----- CONF (unzip -> prune) -----
                if [ \\"$MODE\\" = \\"BIN_AND_CONF\\" ] || [ \\"$MODE\\" = \\"CONF_ONLY\\" ]; then
                  STAGE_DIR=\\"/tmp/${params.APP}-conf-stage-$$\\"
                  rm -rf \\"$STAGE_DIR\\"
                  mkdir -p \\"$STAGE_DIR\\"
                  unzip -o \\"/tmp/${env.CONF_ARTIFACT}-${params.CONF_VERSION}.zip\\" -d \\"$STAGE_DIR\\"

                  rm -rf \\"$CONFIG_DIR\\"/*
                  mkdir -p \\"$CONFIG_DIR\\"

                  cp -f \\"$STAGE_DIR/application.properties\\" \\"$CONFIG_DIR/\\" 2>/dev/null || true
                  cp -f \\"$STAGE_DIR/application-${params.ENV}.properties\\" \\"$CONFIG_DIR/\\" 2>/dev/null || true
                  if [ -n \\"$COLOR\\" ]; then
                    cp -f \\"$STAGE_DIR/application-${params.ENV}-\${COLOR}.properties\\" \\"$CONFIG_DIR/\\" 2>/dev/null || true
                  fi

                  rm -rf \\"$STAGE_DIR\\"
                fi

                # ----- JAR overwrite (atomique) -----
                if [ \\"$MODE\\" = \\"BIN_AND_CONF\\" ] || [ \\"$MODE\\" = \\"BIN_ONLY\\" ]; then
                  TMP_JAR=\\"$LIB_DIR/${params.APP}.jar.new\\"
                  mv \\"/tmp/${params.APP}.jar\\" \\"$TMP_JAR\\"
                  mv -f \\"$TMP_JAR\\" \\"$LIB_DIR/${params.APP}.jar\\"
                fi

                # ----- Deploy info (Hawtio/JMX via Actuator info.*) -----
                DEPLOYED_AT=\\"\\$(date --iso-8601=seconds)\\"
                JAR_RESOLVED=\\"\\"
                [ -f /tmp/jar_resolved_name.txt ] && JAR_RESOLVED=\\"\\$(cat /tmp/jar_resolved_name.txt)\\"

                cat > \\"$APP_DIR/deployed.txt\\" <<EOF
app=$APP
instance=${params.APP}-${params.INSTANCE}
env=$ENV
color=$COLOR
deployMode=$MODE
jarVersion=${params.JAR_VERSION ?: ''}
jarResolved=$JAR_RESOLVED
confVersion=${params.CONF_VERSION ?: ''}
deployedAt=$DEPLOYED_AT
EOF

                cat > \\"$CONFIG_DIR/deploy-info.properties\\" <<EOF
info.app=$APP
info.instance=${params.APP}-${params.INSTANCE}
info.env=$ENV
info.color=$COLOR
info.deploy.mode=$MODE
info.jar.version=${params.JAR_VERSION ?: ''}
info.jar.resolved=$JAR_RESOLVED
info.conf.version=${params.CONF_VERSION ?: ''}
info.deployed.at=$DEPLOYED_AT
EOF

                if [ -x \\"$BIN_DIR/restart.sh\\" ]; then
                  run_script restart.sh
                else
                  run_script start.sh
                fi
              "'
            """
          }
        }
      }
    }
  }
}
