import groovy.json.JsonSlurper
import java.util.Base64
import jenkins.model.Jenkins
import com.cloudbees.plugins.credentials.CredentialsProvider
import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials

// ===== PARAMÈTRES =====
def app       = "eai-camel-rgv"
def groupPath = "fr/labanquepostale/marches/eai"
def repos     = ["libs-release-local", "libs-snapshot-local"]

def baseUrl = System.getenv("EAI_ARTIFACTORY_URL")
        ?: "https://dlu.pop.sf.intra.laposte.fr/artifactory"

def CRED_ID = "usr_gitlab_eai"
// ======================

if (!app || !baseUrl || !groupPath) return ["(missing params)"]

baseUrl = baseUrl.trim()
if (baseUrl.endsWith("/")) baseUrl = baseUrl[0..-2]
if (!baseUrl.contains("/artifactory")) baseUrl = baseUrl + "/artifactory"

// credentials
def creds = CredentialsProvider.lookupCredentials(
  StandardUsernamePasswordCredentials,
  Jenkins.instance,
  null,
  null
).find { it.id == CRED_ID }

if (!creds) return ["(credential not found: ${CRED_ID})"]

def user  = creds.username
def token = creds.password?.plainText
if (!user || !token) return ["(empty credential)"]

def auth = Base64.encoder.encodeToString("${user}:${token}".getBytes("UTF-8"))

def fetchAql = { String repo ->
  // $match doit être littéral => ${'$'}match
  def aql = """
items.find({
  "repo": "${repo}",
  "path": {"${'$'}match":"${groupPath}/${app}/*"},
  "name": {"${'$'}match":"${app}-*.jar"}
}).include("repo","path","name")
"""
  def url = new URL("${baseUrl}/api/search/aql")
  def conn = (HttpURLConnection) url.openConnection()
  conn.setRequestMethod("POST")
  conn.setDoOutput(true)
  conn.setConnectTimeout(5000)
  conn.setReadTimeout(15000)
  conn.setRequestProperty("Authorization", "Basic ${auth}")
  conn.setRequestProperty("Content-Type", "text/plain; charset=UTF-8")
  conn.outputStream.withWriter("UTF-8") { it << aql }

  int rc = conn.responseCode
  def stream = (rc >= 200 && rc < 300) ? conn.inputStream : conn.errorStream
  def payload = stream ? stream.getText("UTF-8") : ""

  if (!(rc >= 200 && rc < 300)) {
    // On renvoie une “pseudo-version” pour voir l’erreur dans l’UI
    return [[_error: "(repo=${repo}) HTTP ${rc} ${payload?.take(200) ?: ''}"]]
  }
  def json = new JsonSlurper().parseText(payload)
  return (json?.results ?: [])
}

def extractVersion = { r ->
  // 1) depuis le path group/app/<version>
  def prefix = "${groupPath}/${app}/"
  def p = r.path as String
  if (p?.startsWith(prefix)) {
    def rest = p.substring(prefix.length())
    def v = rest.tokenize('/')[0]
    if (v) return v
  }
  // 2) fallback depuis le nom app-<version>.jar
  def n = r.name as String
  def m = (n =~ /^${java.util.regex.Pattern.quote(app)}-(.+)\.jar$/)
  return m.matches() ? m[0][1] : null
}

// 1) fetch sur les 2 repos
def allResults = repos.collectMany { fetchAql(it) }

// Si une requête a renvoyé une erreur, on l’affiche
def errors = allResults.findAll { it instanceof Map && it._error }.collect { it._error }
if (errors) return errors

// 2) versions + tag release/snapshot
def items = allResults.collect { r ->
  def v = extractVersion(r)
  if (!v) return null
  def repo = (r.repo ?: "") as String
  def label = repo.contains("snapshot") ? "snapshot" : "release"
  return [version: v, label: label]
}.findAll { it }

// 3) dédoublonnage (si même version existe dans les 2, on préfère release)
def byVersion = [:]
items.each { it ->
  def v = it.version
  if (!byVersion.containsKey(v)) {
    byVersion[v] = it.label
  } else {
    if (byVersion[v] == "snapshot" && it.label == "release") {
      byVersion[v] = "release"
    }
  }
}

// 4) sortie affichée
def out = byVersion.collect { k, v -> "${k} (${v})" }
return out ? out.sort().reverse() : ["(no versions found)"]
