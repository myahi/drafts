pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  environment {
    ART_URL  = 'https://dlu.pop.sf.intra.laposte.fr/artifactory'
    ART_CRED = 'eai-marches-0002775-tech-ci-snapshot-user'

    GROUP_PATH = 'fr/labanquepostale/marches/eai'

    JAR_REPO  = 'eai-marches-0002775-maven-local-sas'
    CONF_REPO = 'eai-marches-0002775-maven-local-sas'

    // IMPORTANT:
    // - en mono-module: CONF_ARTIFACT peut rester fixé (ou dérivé)
    // - en multi-module: on dérive par convention: <module>-conf
    CONF_ARTIFACT = 'eai-camel-rgv-conf'

    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
  }

  stages {

    stage('Resolve & validate') {
      steps {
        script {
          def MATRIX = [
            "eai-camel-rgv": [
              dev:     [ mono: ['sdv4eai02'] ],
              recette: [ mono: ['src4eai02'] ],
              preprod: [ mono: ['spp4eai02'] ],
              prod:    [ mono: ['spr4eai02'] ]
            ]
            // Ajoute ici tes autres applis parent (y compris multi-modules) si besoin
            // "eai-camel-report": [ ... ]
          ]

          def needsJar  = (params.DEPLOY_MODE in ['BIN_AND_CONF','BIN_ONLY'])
          def needsConf = (params.DEPLOY_MODE in ['BIN_AND_CONF','CONF_ONLY'])

          if (needsJar && !params.JAR_VERSION?.trim())   error("JAR_VERSION requis pour ${params.DEPLOY_MODE}")
          if (needsConf && !params.CONF_VERSION?.trim()) error("CONF_VERSION requis pour ${params.DEPLOY_MODE}")

          env.NEEDS_JAR  = needsJar.toString()
          env.NEEDS_CONF = needsConf.toString()

          def envMap = MATRIX[params.APP]?.get(params.ENV)
          if (!envMap) error("ENV non supporté: APP=${params.APP} ENV=${params.ENV}")

          def allowed = envMap.keySet().toList().sort()
          if (!allowed.contains(params.INSTANCE)) {
            error("INSTANCE '${params.INSTANCE}' non autorisée pour ${params.APP}/${params.ENV}. Autorisées: ${allowed}")
          }

          def targets = envMap[params.INSTANCE]
          if (!targets || targets.isEmpty()) error("Aucune VM configurée pour APP=${params.APP} ENV=${params.ENV} INSTANCE=${params.INSTANCE}")

          env.TARGET_VMS = targets.join(',')

          echo """
========== PLAN ==========
PARENT APP   : ${params.APP}
ENV          : ${params.ENV}
INSTANCE     : ${params.INSTANCE}
MODE         : ${params.DEPLOY_MODE}
TARGETS      : ${env.TARGET_VMS}
JAR_VERSION  : ${params.JAR_VERSION}
CONF_VERSION : ${params.CONF_VERSION}
========================
"""
        }
      }
    }

    stage('Checkout (for module detection)') {
      steps {
        // Nécessaire uniquement pour découvrir mono/multi-module via pom.xml
        checkout scm
        sh 'ls -la'
      }
    }

    stage('Detect modules (mono or multi)') {
      steps {
        script {
          def readXml = { String path ->
            new XmlSlurper(false, false).parseText(readFile(path))
          }

          if (!fileExists('pom.xml')) {
            // Si jamais le repo n'est pas maven, fallback mono
            env.MODULES = params.APP
            echo "No pom.xml -> fallback mono: MODULES=${env.MODULES}"
            return
          }

          def parentPom = readXml('pom.xml')
          def moduleDirs = parentPom.modules?.module?.collect { it.text().trim() }?.findAll { it } ?: []

          if (!moduleDirs) {
            // Mono-module : on déploie l'artifactId = params.APP (comme avant)
            env.MODULES = params.APP
            echo "Mono-module detected -> MODULES=${env.MODULES}"
            return
          }

          // Multi-module : on récupère artifactId de chaque module (pom.xml du module)
          def moduleArtifactIds = moduleDirs.collect { m ->
            def p = "${m}/pom.xml"
            if (!fileExists(p)) error("pom.xml introuvable pour le module: ${m} (attendu: ${p})")
            def mpom = readXml(p)
            def aid = mpom.artifactId?.text()?.trim()
            if (!aid) error("artifactId introuvable dans ${p}")
            return aid
          }.unique()

          // Optionnel: filtrage si tu as des modules non déployables (commons/model/etc.)
          // Par défaut, on déploie tout. Si besoin, active un filtre conventionnel:
          // moduleArtifactIds = moduleArtifactIds.findAll { it.endsWith('-boot') || it.endsWith('-service') }

          env.MODULES = moduleArtifactIds.join(',')
          echo "Multi-module detected -> MODULES=${env.MODULES}"
        }
      }
    }

    stage('Preflight SSH') {
      steps {
        script {
          def hosts = env.TARGET_VMS.split(',')
          hosts.each { host ->
            sh """
              set -euo pipefail
              ssh ${env.SSH_OPTS} "${host}" "echo OK: \$(hostname) as \$(whoami)"
            """
          }
        }
      }
    }

    stage('Prepare remote deploy script') {
      steps {
        script {
          // Script exécuté SUR LA VM CIBLE
          // Structure cible:
          // /serveur_apps/<PARENT>-<INSTANCE>/<MODULE>/{bin,lib,config}
          // jar stable: lib/<module>-<version>.jar + symlink lib/app.jar (standard)
          def scriptText = '''#!/usr/bin/env bash
set -euo pipefail

PARENT_APP="$1"         # projet parent (celui choisi dans l'UI)
MODULE="$2"             # artifactId du module à déployer (ou identique au parent en mono)
ENV_NAME="$3"
INSTANCE="$4"
MODE="$5"
JAR_VERSION_UI="${6:-}"
CONF_VERSION_UI="${7:-}"

APPS_BASE="/serveur_apps"

PARENT_DIR="${APPS_BASE}/${PARENT_APP}-${INSTANCE}"
MOD_DIR="${PARENT_DIR}/${MODULE}"

BIN_DIR="${MOD_DIR}/bin"
LIB_DIR="${MOD_DIR}/lib"
CONFIG_DIR="${MOD_DIR}/config"

COLOR=""
if [[ "$INSTANCE" != "mono" ]]; then
  COLOR="$INSTANCE"
fi

mkdir -p "$BIN_DIR" "$LIB_DIR" "$CONFIG_DIR"

run_script() {
  local s="$1"
  if [[ -x "$BIN_DIR/$s" ]]; then
    if [[ -z "$COLOR" ]]; then
      "$BIN_DIR/$s" "$ENV_NAME"
    else
      "$BIN_DIR/$s" "$ENV_NAME" "$COLOR"
    fi
  fi
}

run_script stop.sh

# ----- CONF install -----
if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "CONF_ONLY" ]]; then
  [[ -f /tmp/conf.zip ]] || { echo "ERROR: /tmp/conf.zip absent"; exit 2; }

  STAGE_DIR="$(mktemp -d "/tmp/${MODULE}-conf-stage-XXXXXX")"
  unzip -o "/tmp/conf.zip" -d "$STAGE_DIR"

  rm -rf "$CONFIG_DIR"/*
  mkdir -p "$CONFIG_DIR"

  cp -f "$STAGE_DIR/application.properties" "$CONFIG_DIR/" 2>/dev/null || true
  cp -f "$STAGE_DIR/application-${ENV_NAME}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  if [[ -n "$COLOR" ]]; then
    cp -f "$STAGE_DIR/application-${ENV_NAME}-${COLOR}.properties" "$CONFIG_DIR/" 2>/dev/null || true
  fi

  rm -rf "$STAGE_DIR"
fi

# ----- JAR install (nom stable + symlink app.jar) -----
if [[ "$MODE" == "BIN_AND_CONF" || "$MODE" == "BIN_ONLY" ]]; then
  [[ -f /tmp/app.jar ]] || { echo "ERROR: /tmp/app.jar absent"; exit 3; }

  mv -f "/tmp/app.jar" "$LIB_DIR/${MODULE}-${JAR_VERSION_UI}.jar"
  ln -sfn "$LIB_DIR/${MODULE}-${JAR_VERSION_UI}.jar" "$LIB_DIR/app.jar"
fi

DEPLOYED_AT="$(date --iso-8601=seconds)"

cat > "$MOD_DIR/deployed.txt" <<EOF
parent=$PARENT_APP
module=$MODULE
instance=${PARENT_APP}-${INSTANCE}
env=$ENV_NAME
color=$COLOR
deployMode=$MODE
jarVersion=$JAR_VERSION_UI
confVersion=$CONF_VERSION_UI
deployedAt=$DEPLOYED_AT
EOF

cat > "$CONFIG_DIR/deploy-info.properties" <<EOF
info.parent=$PARENT_APP
info.module=$MODULE
info.instance=${PARENT_APP}-${INSTANCE}
info.env=$ENV_NAME
info.color=$COLOR
info.deploy.mode=$MODE
info.jar.version=$JAR_VERSION_UI
info.conf.version=$CONF_VERSION_UI
info.deployed.at=$DEPLOYED_AT
EOF

if [[ -x "$BIN_DIR/restart.sh" ]]; then
  run_script restart.sh
else
  run_script start.sh
fi
'''
          writeFile file: 'deploy_remote.sh', text: scriptText
          sh 'chmod +x deploy_remote.sh'
        }
      }
    }

    stage('Deploy (loop modules)') {
      steps {
        script {
          def modules = (env.MODULES ?: params.APP).split(',').collect { it.trim() }.findAll { it }
          if (!modules) error("MODULES vide, impossible de déployer")

          withCredentials([usernamePassword(credentialsId: env.ART_CRED, usernameVariable: 'ART_USER', passwordVariable: 'ART_PASS')]) {

            // --- Fonctions identiques à ta logique actuelle (download via maven-metadata.xml) ---
            def resolveSnapshotFilename = { String repo, String groupPath, String artifactId, String version, String ext ->
              def metaUrl = "${env.ART_URL}/${repo}/${groupPath}/${artifactId}/${version}/maven-metadata.xml"

              def xml = sh(
                returnStdout: true,
                script: """
                  set -euo pipefail
                  curl -fsS -u "${ART_USER}:${ART_PASS}" "${metaUrl}"
                """
              ).trim()

              def value = (xml =~ /<snapshotVersion>\\s*<extension>${ext}<\\/extension>\\s*(?:<classifier>[^<]+<\\/classifier>\\s*)?<value>([^<]+)<\\/value>/)
              if (value.find()) {
                def v = value.group(1)
                return "${artifactId}-${v}.${ext}"
              }

              def ts = (xml =~ /<timestamp>([^<]+)<\\/timestamp>/)
              def bn = (xml =~ /<buildNumber>([^<]+)<\\/buildNumber>/)
              if (ts.find() && bn.find()) {
                def baseVer = version.replaceAll(/-SNAPSHOT$/, "")
                return "${artifactId}-${baseVer}-${ts.group(1)}-${bn.group(1)}.${ext}"
              }
              return null
            }

            def download = { String url, String outFile ->
              sh """
                set -euo pipefail
                echo "Downloading: ${url}"
                curl -f -u "${ART_USER}:${ART_PASS}" -o "${outFile}" "${url}"
              """
            }

            def hosts = env.TARGET_VMS.split(',')

            modules.each { moduleArtifactId ->
              echo "===== DEPLOY MODULE: ${moduleArtifactId} ====="
              sh 'mkdir -p artifacts && rm -f artifacts/* || true'

              // ---- CONF (convention: <module>-conf). En mono, tu peux garder env.CONF_ARTIFACT si tu veux.
              if (env.NEEDS_CONF == "true") {
                def confArtifactId = (modules.size() == 1 && moduleArtifactId == params.APP) ? env.CONF_ARTIFACT : "${moduleArtifactId}-conf"

                def confResolved
                if (params.CONF_VERSION.endsWith("-SNAPSHOT")) {
                  confResolved = resolveSnapshotFilename(env.CONF_REPO, env.GROUP_PATH, confArtifactId, params.CONF_VERSION, "zip")
                  if (!confResolved) error("Impossible de résoudre le conf SNAPSHOT via maven-metadata.xml pour ${confArtifactId} ${params.CONF_VERSION}")
                } else {
                  confResolved = "${confArtifactId}-${params.CONF_VERSION}.zip"
                }

                def confUrl = "${env.ART_URL}/${env.CONF_REPO}/${env.GROUP_PATH}/${confArtifactId}/${params.CONF_VERSION}/${confResolved}"
                download(confUrl, "artifacts/conf.zip")
              }

              // ---- JAR (nom stable sans timestamp)
              if (env.NEEDS_JAR == "true") {
                def jarResolved
                if (params.JAR_VERSION.endsWith("-SNAPSHOT")) {
                  jarResolved = resolveSnapshotFilename(env.JAR_REPO, env.GROUP_PATH, moduleArtifactId, params.JAR_VERSION, "jar")
                  if (!jarResolved) error("Impossible de résoudre le jar SNAPSHOT via maven-metadata.xml pour ${moduleArtifactId} ${params.JAR_VERSION}")
                } else {
                  jarResolved = "${moduleArtifactId}-${params.JAR_VERSION}.jar"
                }

                def jarUrl  = "${env.ART_URL}/${env.JAR_REPO}/${env.GROUP_PATH}/${moduleArtifactId}/${params.JAR_VERSION}/${jarResolved}"
                def finalJar = "artifacts/${moduleArtifactId}-${params.JAR_VERSION}.jar"
                download(jarUrl, finalJar)
              }

              sh 'ls -lh artifacts || true'

              // ---- Copy + Deploy sur chaque host
              hosts.each { host ->
                sh """
                  set -euo pipefail
                  echo "=== Copy to ${host} (${moduleArtifactId}) ==="
                  scp ${env.SSH_OPTS} deploy_remote.sh "${host}:/tmp/deploy_remote.sh"
                  ${env.NEEDS_JAR == "true" ? "scp ${env.SSH_OPTS} artifacts/${moduleArtifactId}-${params.JAR_VERSION}.jar \"${host}:/tmp/app.jar\"" : "true"}
                  ${env.NEEDS_CONF == "true" ? "scp ${env.SSH_OPTS} artifacts/conf.zip \"${host}:/tmp/conf.zip\"" : "true"}

                  echo "=== Deploy on ${host} (${moduleArtifactId}) ==="
                  ssh ${env.SSH_OPTS} "${host}" "bash /tmp/deploy_remote.sh \
                    '${params.APP}' \
                    '${moduleArtifactId}' \
                    '${params.ENV}' \
                    '${params.INSTANCE}' \
                    '${params.DEPLOY_MODE}' \
                    '${params.JAR_VERSION ?: ''}' \
                    '${params.CONF_VERSION ?: ''}'"
                """
              }
            }
          }
        }
      }
    }
  }
}
