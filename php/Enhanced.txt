Oui, bien sÃ»r ğŸ˜Š
Je te redonne tout, fichier par fichier, uniquement avec des petites modifs localisÃ©es.


---

1ï¸âƒ£ auditView.php (page front)

1.1. Bouton Annuler dans le HTML

AVANT :

<button type="button" class="btn btn-warning" id="cancelBtn" onclick="showLoading()">Annuler</button>

APRÃˆS : (on enlÃ¨ve lâ€™onclick, il est contraire au comportement attendu)

<button type="button" class="btn btn-warning" id="cancelBtn">Annuler</button>


---

1.2. Gestion du submit du formulaire #auditform

RepÃ¨re ce bloc dans ton JS :

document.getElementById('auditform').addEventListener("submit", function(e) {
    e.preventDefault();
    // CrÃ©er un nouveau controller
    let fd = new FormData(this);
    currentXHR = new XMLHttpRequest();
    showLoading();
    let filetredFlows = flowList.filter(flow => selectedFlows.includes(flow.flowName));
    let flows = filetredFlows.map(flow => flow.projects.join(";"));
    fd.append("FLOWS",flows);
    fd.append("DISPLAYED_FLOW_TAGS",selectedFlows.join(";"));
    currentXHR.open("POST", this.getAttribute('action'),true);
    currentXHR.onload = function(){
        if(currentXHR.status===200){
        try {
        $('#auditTable').bootstrapTable('refresh');
        }
         catch (e) {
             hideLoading();
        }
        finally {
        }
        }
     };
     currentXHR.send(fd);
  });

Remplace-le entiÃ¨rement par :

document.getElementById('auditform').addEventListener("submit", function(e) {
    e.preventDefault();

    // ğŸ”’ Si une requÃªte est dÃ©jÃ  en cours, on lâ€™annule pour Ã©viter les doublons
    if (currentXHR && currentXHR.readyState !== 4) {
        currentXHR.abort();
        currentXHR = null;
    }

    let fd = new FormData(this);
    currentXHR = new XMLHttpRequest();
    showLoading();

    let filetredFlows = flowList.filter(flow => selectedFlows.includes(flow.flowName));
    let flows = filetredFlows.map(flow => flow.projects.join(";"));
    fd.append("FLOWS", flows);
    fd.append("DISPLAYED_FLOW_TAGS", selectedFlows.join(";"));

    currentXHR.open("POST", this.getAttribute('action'), true);

    // ğŸ”‘ Permet Ã  PHP de savoir que câ€™est un appel AJAX
    currentXHR.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

    currentXHR.onload = function () {
        try {
            if (currentXHR.status === 200) {
                // On ne se sert pas du body, les critÃ¨res sont en session
                $('#auditTable').bootstrapTable('refresh');
            } else {
                console.error("Erreur POST AuditLoaderForSearch, status=" + currentXHR.status);
            }
        } finally {
            hideLoading();
            currentXHR = null;
        }
    };

    currentXHR.onerror = function () {
        console.error("Erreur rÃ©seau sur AuditLoaderForSearch");
        hideLoading();
        currentXHR = null;
    };

    currentXHR.onabort = function () {
        hideLoading();
        currentXHR = null;
    };

    currentXHR.send(fd);
});


---

1.3. Listener sur #cancelBtn

Tu as dÃ©jÃ  ce bloc :

document.getElementById('cancelBtn').addEventListener("click", function(){
    if (currentXHR) {
        hideLoading();
        currentXHR.abort();
        currentXHR = null;
    }
});

Tu peux le laisser comme Ã§a, ou le rendre un poil plus logique (dâ€™abord abort, puis cacher) :

document.getElementById('cancelBtn').addEventListener("click", function(){
    if (currentXHR) {
        currentXHR.abort();
        currentXHR = null;
    }
    hideLoading();
});


---

2ï¸âƒ£ AuditLoaderForSearch.php

On touche uniquement Ã  la fin du fichier, lÃ  oÃ¹ tu fais toujours une redirection.

2.1. Remplacer le bloc final

AVANT :

if (isset( $_POST['intervalle']) || ! empty($_POST['intervalle'])) {
        $intervalle =  $_POST['intervalle'];
        $_SESSION['recherche_intervalle'] = $_POST['intervalle'];
    }
    
    header('Location: auditView.php');
} catch(Exception $e) {
    header('Location: auditView.php?error='.$e->getMessage()); 
}
?>

APRÃˆS :

if (isset( $_POST['intervalle']) || ! empty($_POST['intervalle'])) {
        $intervalle =  $_POST['intervalle'];
        $_SESSION['recherche_intervalle'] = $_POST['intervalle'];
    }

    // On a terminÃ© d'Ã©crire dans la session, on libÃ¨re le verrou
    session_write_close();

    // DÃ©tection d'un appel AJAX (XHR depuis auditView.php)
    $isAjax = !empty($_SERVER['HTTP_X_REQUESTED_WITH'])
        && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest';

    if ($isAjax) {
        // Appel AJAX : pas besoin de redirection, juste un OK
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode(['status' => 'ok']);
        exit;
    } else {
        // Comportement historique : redirection vers la vue
        header('Location: auditView.php');
        exit;
    }

} catch(Exception $e) {

    $isAjax = !empty($_SERVER['HTTP_X_REQUESTED_WITH'])
        && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest';

    if ($isAjax) {
        http_response_code(500);
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode([
            'status'  => 'error',
            'message' => $e->getMessage()
        ]);
        exit;
    } else {
        header('Location: auditView.php?error=' . urlencode($e->getMessage()));
        exit;
    }
}
?>

ğŸ‘‰ RÃ©sultat :

Quand lâ€™appel vient de ton XMLHttpRequest, PHP ne fait plus de 302 vers auditView.php, il renvoie juste {status:"ok"}.

Ã‡a rÃ©duit la chaÃ®ne de requÃªtes et les effets â€œboucleâ€.

La navigation â€œclassiqueâ€ (POST direct, sans JS) continue de rediriger comme avant.



---

3ï¸âƒ£ AuditLoader.php

Ici on allÃ¨ge la pression sur la session pour Ã©viter les blocages quand plusieurs requÃªtes arrivent en mÃªme temps.

RepÃ¨re cette partie vers le milieu :

$intervalle = isset($_GET['intervalle']) ? (int)$_GET['intervalle'] : 50;
    
    // Creation des objets DAO
    $auditDAO = new AuditDAO ();
    $auditKeywordDAO = new AuditKeywordDAO();

Devient :

$intervalle = isset($_GET['intervalle']) ? (int)$_GET['intervalle'] : 50;

    // On a fini de lire $_SESSION dans ce script, on peut libÃ©rer le verrou
    if (session_status() === PHP_SESSION_ACTIVE) {
        session_write_close();
    }
    
    // Creation des objets DAO
    $auditDAO = new AuditDAO ();
    $auditKeywordDAO = new AuditKeywordDAO();

ğŸ‘‰ Ici, on ne change pas ta logique mÃ©tier, on dit juste Ã  PHP :

> "Jâ€™ai terminÃ© avec la session, tu peux la dÃ©verrouiller."



Ã‡a Ã©vite quâ€™un long getAuditData() bloque dâ€™autres requÃªtes qui veulent aussi accÃ©der Ã  la session.


---

4ï¸âƒ£ Effet global sur ton problÃ¨me

Ces petites modifs vont :

empÃªcher plusieurs POST de recherche de tourner en mÃªme temps ;

Ã©viter la redirection inutile AuditLoaderForSearch.php â†’ auditView.php en AJAX ;

rÃ©duire les risques de blocage de session entre AuditLoaderForSearch.php et AuditLoader.php ;

mieux gÃ©rer lâ€™affichage / masquage de ton modal â€œChargementâ€¦â€.


Tu peux appliquer Ã§a tel quel.
Si ensuite tu constates encore des cas de â€œboucleâ€, on regardera ensemble les scripts cÃ´tÃ© serveur qui peuvent Ãªtre longs (AuditDAO, JMSHelper.php, etc.) pour mettre des timeouts / logs ciblÃ©s.
