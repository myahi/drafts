Yes, exactement :
tu as bien 2 requÃªtes (POST + GET), et chacune dÃ©clenche showLoading() / hideLoading(), donc ton modal â€œLoadingâ€¦â€ sâ€™ouvre / se ferme 2 fois pour un seul clic â†’ impression que Ã§a â€œclignoteâ€ / â€œrend la main tardâ€.

On va corriger Ã§a proprement sans tout casser, juste en amÃ©liorant la gestion du loader.


---

1. Pourquoi Ã§a clignote 2 fois

Pour un clic sur Rechercher :

1. Ton JS envoie un POST vers AuditLoaderForSearch.php
â†’ tu appelles showLoading() dans le submit handler.


2. Quand ce POST rÃ©pond, tu fais $('#auditTable').bootstrapTable('refresh');
â†’ le tableau fait un GET vers AuditLoader.php.
â†’ tu as aussi :

$('#auditTable').on('pre-body.bs.table', function (e, number, size) {
    showLoading();
});

$('#auditTable').on('post-body.bs.table', function (e, data) {
    hideLoading();
});



Donc le mÃªme modal est pilotÃ© par :

le POST (submit)

le GET (pre-body / post-body de bootstrapTable)


RÃ©sultat typique :

1. submit â†’ showLoading()


2. POST terminÃ© â†’ hideLoading()


3. table refresh â†’ showLoading()


4. GET terminÃ© â†’ hideLoading()



â†’ visuellement : il apparaÃ®t / disparaÃ®t deux fois.


---

2. Solution simple sans changer toute la logique

On va :

1. Garder les showLoading() / hideLoading() partout oÃ¹ ils sont (submit + pre-body + post-body, etc.)


2. Mais transformer ces fonctions pour gÃ©rer un compteur global, et ne cacher le modal que quand tout est fini.



2.1. Remplace les fonctions showLoading / hideLoading

Dans auditView.php, tu as aujourdâ€™hui :

function showLoading(){
    $('#loadingModal').modal('show');
}

function hideLoading(){
    $('#loadingModal').modal('hide');
}

Remplace par :

let loadingCounter = 0;

function showLoading() {
    loadingCounter++;
    $('#loadingModal').modal('show');
}

function hideLoading() {
    if (loadingCounter > 0) {
        loadingCounter--;
    }
    if (loadingCounter === 0) {
        $('#loadingModal').modal('hide');
    }
}

ğŸ‘‰ Effet :

Si le POST et le GET appellent chacun showLoading(), le compteur passe Ã  2.

Quand le POST se termine et appelle hideLoading(), compteur = 1 â†’ le modal reste ouvert.

Quand le GET se termine et appelle hideLoading(), compteur = 0 â†’ le modal se ferme une seule fois, Ã  la toute fin.


Donc tu nâ€™as plus le â€œdouble clignotementâ€.


---

3. Pense aussi au bouton Annuler

Dans le HTML, vÃ©rifie que ton bouton Annuler du loading a bien plus ce onclick="showLoading()" :

<button type="button" class="btn btn-warning" id="cancelBtn">Annuler</button>

Et garde ce JS (ou ajoute loadingCounter = 0; pour Ãªtre sÃ»r) :

document.getElementById('cancelBtn').addEventListener("click", function(){
    if (currentXHR) {
        currentXHR.abort();
        currentXHR = null;
    }
    loadingCounter = 0;
    hideLoading();
});


---

4. RÃ©sumÃ©

Deux requÃªtes par recherche (1 POST AuditLoaderForSearch.php + 1 GET AuditLoader.php) â†’ normal.

Le problÃ¨me Ã©tait juste que ton loader Ã©tait contrÃ´lÃ© par les deux de faÃ§on indÃ©pendante â†’ 2 cycles ouverture/fermeture.

Avec le compteur dans showLoading/hideLoading, ton modal ne se ferme quâ€™une fois que TOUT est terminÃ©, donc plus de clignotement.


Tu peux appliquer juste ces changements-lÃ , sans toucher au reste, et tester.
Si aprÃ¨s Ã§a il reste encore un comportement visuel bizarre, on regardera ensemble les classes modal-open / modal-open-fullscreen sur le <body>. 
