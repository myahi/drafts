pipeline {
agent any
options { timestamps(); disableConcurrentBuilds() }

  environment {
    APP_HOST = 'sdv4eai02'
    APP_DATA_DIR = '/serveur_apps/easy-tnr/data/'
    APP_SCRIPT = '/serveur_apps/easy-tnr/scripts/start_batch.sh'
    REPO_URL = 'https://gitlab.pop.sf.intra.laposte.fr/bfi-mar-tpma/eai-marches/sources-eai/tnr-data.git'
    RSYNC_OPTS = '-q -c aes128-ctr -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
    SSH_OPTS = '-q -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=5'
	GIT_CRED = 'usr_gitlab_eai'
  }

  stages {

  stage('Checkout TNR data from repository') {
  steps {
    script {
      try {
        // Supprime tout le contenu du workspace actuel avant de commencer
        deleteDir() 
        
        def branch = 'develop'
        echo "Checkout repo=${env.REPO_URL} branch=${branch}"
        
        checkout([
          $class: 'GitSCM',
          branches: [[name: branch]],
          userRemoteConfigs: [[
            url: env.REPO_URL,
            credentialsId: env.GIT_CRED
          ]]
        ])
      } catch (e) {
        echo "Erreur pendant le checkout : ${e.toString()}"
        throw e
      }
    }
  }
}
stage('Sync to sdv4eai02') {
  steps {
    script {
	try {
       withEnv(['LANG=C.UTF-8','LC_ALL=C.UTF-8']) {

        sh """
          ssh ${SSH_OPTS} ${env.EAI_SSH_USER}@${APP_HOST} '
            set -e
            rm -rf ${APP_DATA_DIR}/*
            mkdir -p ${APP_DATA_DIR}
          '
        """

        sh """
          rsync -a --delete --checksum \
            --rsync-path="LANG=C.UTF-8 LC_ALL=C.UTF-8 rsync" \
            -e "ssh ${RSYNC_OPTS}" \
            ./ \
            ${env.EAI_SSH_USER}@${APP_HOST}:${APP_DATA_DIR}
        """
      }
	}
	catch (e) {
        echo "Erreur pendant le stage: Sync to sdv4eai02"
        echo e.toString()
        throw e
      }
  }
  }
}
stage('Run MAESTRO_BLOOMBERG_REPO') {
    when { expression { return params.MAESTRO_BLOOMBERG_REPO } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_BLOOMBERG_REPO', 'MAESTRO/BLOOMBERG_TO_CALYPSO/REPO')
            }
        }
    }
}

stage('Run BLOOMBERG_BOND_TOMS') {
    when { expression { return params.BLOOMBERG_BOND_TOMS } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('BLOOMBERG_BOND_TOMS', 'MAESTRO/BLOOMBERG_TO_CALYPSO/BOND_TOMS')
            }
        }
    }
}

stage('Run MAESTRO_BLOOMBERG_BOND') {
    when { expression { return params.MAESTRO_BLOOMBERG_BOND } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_BLOOMBERG_BOND', 'MAESTRO/BLOOMBERG_TO_CALYPSO/BOND')
            }
        }
    }
}
stage('Run MAESTRO_GLMX_REPO') {
    when { expression { return params.MAESTRO_GLMX_REPO } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_GLMX_REPO', 'MAESTRO/GLMX_TO_CALYPSO/REPO')
            }
        }
    }
}
stage('Run MAESTRO_CME_REPO') {
    when { expression { return params.MAESTRO_CME_REPO } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_CME_REPO', 'MAESTRO/CME_TO_CALYPSO/REPO')
            }
        }
    }
}
stage('Run MAESTRO_360T_FX_FWD') {
    when { expression { return params.MAESTRO_360T_FX_FWD } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_360T_FX_FWD', 'MAESTRO/360T_TO_CALYPSO/FX_FWD')
            }
        }
    }
}
stage('Run MAESTRO_360T_FX_SPOT') {
    when { expression { return params.MAESTRO_360T_FX_SPOT } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_360T_FX_SPOT', 'MAESTRO/360T_TO_CALYPSO/FX_SPOT')
            }
        }
    }
}
stage('Run MAESTRO_360T_FX_SWAP') {
    when { expression { return params.MAESTRO_360T_FX_SWAP } }
    steps {
        script {
            // catchError intercepte l'exit 1 du shell et continue la suite
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                runTnrStage('MAESTRO_360T_FX_SWAP', 'MAESTRO/360T_TO_CALYPSO/FX_SWAP')
            }
        }
    }
}

  }
}


def runTnrStage(stageName, scenarioPath) {
    // Le nom du fichier log doit être unique si vous lancez des stages en parallèle
    def logFile = "output_${stageName}.log"
    
    try {
        sh """
            ssh ${SSH_OPTS} ${env.EAI_SSH_USER}@${APP_HOST} "
                ${env.APP_SCRIPT} DEVEAI ${stageName} '${scenarioPath}' \
				-Dfile.encoding=UTF-8 \
				-Dsun.jnu.encoding=UTF-8 \
                -DMaestroDBURL=${params.MaestroDBURL} \
                -DMaestroDBUser=${params.MaestroDBUser} \
                -DMaestroDBPWD=${params.MaestroDBPWD} \
                -DEAIScenarioBasePath=${params.EAIScenarioBasePath} \
                -DTNRFolder=${params.TNRFolder} \
                -DmaestroProjectName=${params.maestroProjectName} \
                -DFTPHost=${params.FTPHost} \
                -DFTPUser=${params.FTPUser} \
                -DFTPPwd=${params.FTPPwd}
            " | tee ${logFile}

            # Si grep trouve un mot clé, il renvoie 0 (succès du grep), 
            # on entre alors dans le bloc pour forcer l'erreur.
            if grep -Ei "failure|ERROR|Difference found" ${logFile}; then
                echo "Anomalie détectée dans le fichier log."
                exit 1
            fi
        """
    } catch (Exception e) {
        // C'est ici qu'on lève l'exception spécifique pour le catch du stage
        error "échec détecté dans les logs pour ${stageName}"
    } finally {
        sh "rm -f ${logFile}"
    }
}
